/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./packages/tempdata/src/scripts/helpers.ts":
/*!**************************************************!*\
  !*** ./packages/tempdata/src/scripts/helpers.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.findChar = findChar;\nexports.hasKeyWithNameSubstring = hasKeyWithNameSubstring;\nexports.matchesCriteria = matchesCriteria;\n/**\r\n * Checks if an element matches all specified criteria.\r\n * \r\n * This function iterates over each key in the criteria object and checks if the element has a matching value for each key.\r\n * \r\n * @param element - The element to check, represented as a record of string keys to any values.\r\n * @param criteria - The criteria to match against, represented as a record of string keys to any values.\r\n * @returns A boolean value indicating whether the element matches all the criteria. Returns `true` if all criteria are matched, `false` otherwise.\r\n */\nfunction matchesCriteria(element, criteria) {\n  return Object.keys(criteria).every(function (key) {\n    return element[key] === criteria[key];\n  });\n}\n\n/**\r\n * Searches for a key within an object that includes a specified substring. Optionally, returns the key name instead of its value.\r\n * \r\n * @param object - The object to search through.\r\n * @param substring - The substring to look for within the object's keys.\r\n * @param getValue - Optional. If `true`, returns the key name that includes the substring. If `false` or omitted, returns the value of the first matching key.\r\n * @returns The value of the first key that includes the substring, the name of the first key that includes the substring if `getValue` is `true`, or `false` if no matching key is found.\r\n */\nfunction hasKeyWithNameSubstring(object, substring, getValue) {\n  for (var key in object) {\n    if (key.includes(substring)) {\n      if (undefined === getValue || false === getValue) {\n        return object[key];\n      }\n      if (true === getValue) {\n        return key;\n      }\n    }\n  }\n  return false;\n}\n/**\r\n * Searches for the first occurrence of a character within a string that represents a number up to a specified limit.\r\n * \r\n * This function iterates through numbers from 0 up to the specified limit and checks if the string contains that number as a character.\r\n * \r\n * @param value - The string to search within.\r\n * @param limit - The maximum number to check for within the string.\r\n * @param returnBool - Optional. If `true`, the function returns a boolean indicating whether any character was found. If `false` or omitted, returns the character itself.\r\n * @returns If `returnBool` is `true`, returns `true` if a matching character is found or `false` otherwise. If `returnBool` is `false`, returns the first found character as a string, or `null` if no character is found.\r\n */\nfunction findChar(value, limit) {\n  var returnBool = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  for (var i = 0; i <= limit; i++) {\n    var index = value.indexOf(i.toString());\n    if (index !== -1) {\n      return returnBool ? true : i.toString();\n    }\n  }\n  return returnBool ? false : null;\n}\n\n//# sourceURL=webpack://@easylibs/easylibs/./packages/tempdata/src/scripts/helpers.ts?");

/***/ }),

/***/ "./packages/tempdata/src/scripts/transformer.ts":
/*!******************************************************!*\
  !*** ./packages/tempdata/src/scripts/transformer.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.FormDataTransformer = exports.BlobTransformer = void 0;\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar BlobTransformer = exports.BlobTransformer = /*#__PURE__*/function () {\n  function BlobTransformer() {\n    _classCallCheck(this, BlobTransformer);\n  }\n  _createClass(BlobTransformer, [{\n    key: \"fromUint8Array\",\n    value:\n    /**\r\n     * Convertit un tableau Uint8Array en objet Blob.\r\n     * @param uint8Array - Le tableau Uint8Array à convertir en Blob.\r\n     * @param contentType - (Optionnel) Le type de contenu du Blob.\r\n     * @returns Le Blob résultant.\r\n     */\n    function fromUint8Array(uint8Array, contentType) {\n      var _contentType;\n      contentType = (_contentType = contentType) !== null && _contentType !== void 0 ? _contentType : \"\";\n      return new Blob([uint8Array], {\n        type: contentType\n      });\n    }\n    /**\r\n     * Crée un Blob à partir d'un objet File.\r\n     * @param file - Le fichier à convertir en Blob.\r\n     * @returns Le Blob résultant.\r\n     */\n  }, {\n    key: \"fromFile\",\n    value: function fromFile(file) {\n      return file.slice(0, file.size, file.type);\n    }\n    /**\r\n     * Crée un Blob à partir d'une chaîne encodée en base64.\r\n     * @param base64String - La chaîne encodée en base64.\r\n     * @param contentType - (Optionnel) Le type de contenu du Blob.\r\n     * @returns Le Blob résultant.\r\n     */\n  }, {\n    key: \"fromBase64String\",\n    value: function fromBase64String(base64String, contentType) {\n      contentType = contentType || \"\";\n      var byteCharacters = window.atob(base64String.split(\",\")[1]);\n      var byteNumbers = new Array(byteCharacters.length);\n      for (var i = 0; i < byteCharacters.length; i++) {\n        byteNumbers[i] = byteCharacters.charCodeAt(i);\n      }\n      var byteArray = new Uint8Array(byteNumbers);\n      return new Blob([byteArray], {\n        type: contentType\n      });\n    }\n  }]);\n  return BlobTransformer;\n}();\nvar FormDataTransformer = exports.FormDataTransformer = /*#__PURE__*/function () {\n  function FormDataTransformer(data) {\n    _classCallCheck(this, FormDataTransformer);\n    this._data = data;\n  }\n  /**\r\n   * Transforme les données en un objet FormData.\r\n   * @returns L'objet FormData résultant.\r\n   */\n  _createClass(FormDataTransformer, [{\n    key: \"transform\",\n    value: function transform() {\n      var formData = new FormData();\n      if (_typeof(this._data) === \"object\") {\n        var data = this._data;\n        try {\n          for (var key in this._data) {\n            if (this._data.hasOwnProperty(key)) {\n              formData.append(key, data[key]);\n            }\n          }\n        } catch (error) {\n          console.error(\"Erreur détectée: \" + error);\n        }\n      }\n      return formData;\n    }\n  }]);\n  return FormDataTransformer;\n}();\n\n//# sourceURL=webpack://@easylibs/easylibs/./packages/tempdata/src/scripts/transformer.ts?");

/***/ }),

/***/ "./packages/tempdata/src/tempdata.ts":
/*!*******************************************!*\
  !*** ./packages/tempdata/src/tempdata.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _helpers = __webpack_require__(/*! ./scripts/helpers */ \"./packages/tempdata/src/scripts/helpers.ts\");\nvar _transformer = __webpack_require__(/*! ./scripts/transformer */ \"./packages/tempdata/src/scripts/transformer.ts\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar TempData = exports[\"default\"] = /*#__PURE__*/function () {\n  /**\r\n   * @param dbname - The name of the IndexedDB database to open or create.\r\n   * @param osname - The name of the object (object store) which will contain the elements to be stored\r\n   * @param version - The version of the IndexedDB database (default: 1).\r\n   */\n  function TempData(dbname, osname) {\n    var version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    _classCallCheck(this, TempData);\n    this.dbname = dbname;\n    this.osname = osname;\n    this.version = version;\n  }\n  /**\r\n   * Adds a new element or elements to the IDBObjectStore with the provided object or array of objects.\r\n   * @param data - Data (a single object or an array of objects) to add to the IDBObjectStore.\r\n   * @returns A promise that resolves to an object indicating the success of the operation.\r\n   */\n  _createClass(TempData, [{\n    key: \"add\",\n    value: (function () {\n      var _add = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(data) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n              return _context2.abrupt(\"return\", this._getObjectStore(\"readwrite\").then(function (objectStore) {\n                var handleData = function handleData(item) {\n                  var request = objectStore.add(item);\n                  return new Promise(function (resolve, reject) {\n                    request.onsuccess = /*#__PURE__*/function () {\n                      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(event) {\n                        var elementId, elementObject;\n                        return _regeneratorRuntime().wrap(function _callee$(_context) {\n                          while (1) switch (_context.prev = _context.next) {\n                            case 0:\n                              if (event.target) {\n                                elementId = event.target.result;\n                                elementObject = item;\n                                elementObject[\"@id\"] = elementId;\n                                objectStore.put(elementObject, elementId);\n                                resolve({\n                                  success: true,\n                                  elementObject: elementObject\n                                });\n                              }\n                            case 1:\n                            case \"end\":\n                              return _context.stop();\n                          }\n                        }, _callee);\n                      }));\n                      return function (_x2) {\n                        return _ref.apply(this, arguments);\n                      };\n                    }();\n                    request.onerror = function (event) {\n                      reject(new Error(\"Failed to add file to IndexedDB: \" + event.target.error));\n                    };\n                  });\n                };\n                if (Array.isArray(data)) {\n                  return Promise.all(data.map(function (item) {\n                    return handleData(item);\n                  })).then(function (results) {\n                    return {\n                      success: true,\n                      elements: results\n                    };\n                  })[\"catch\"](function (error) {\n                    return {\n                      success: false,\n                      error: error.message\n                    };\n                  });\n                } else {\n                  return handleData(data);\n                }\n              }));\n            case 4:\n              _context2.prev = 4;\n              _context2.t0 = _context2[\"catch\"](0);\n              console.error(\"Error accessing IndexedDB\", _context2.t0);\n              return _context2.abrupt(\"return\", {\n                success: false\n              });\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[0, 4]]);\n      }));\n      function add(_x) {\n        return _add.apply(this, arguments);\n      }\n      return add;\n    }()\n    /**\r\n     * Retrieves the form data at the specified index from the array of object data obtained from `getIndexedData`.\r\n     * @param i - The index of the form data to retrieve.\r\n     * @returns A promise that resolves to the form data at the specified index, or `undefined` if the index is out of range.\r\n     */\n    )\n  }, {\n    key: \"readOne\",\n    value: function readOne(i, type) {\n      var _this = this;\n      try {\n        return new Promise( /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(resolve, reject) {\n            var objectStore, request;\n            return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n              while (1) switch (_context4.prev = _context4.next) {\n                case 0:\n                  _context4.next = 2;\n                  return _this._getObjectStore(\"readonly\");\n                case 2:\n                  objectStore = _context4.sent;\n                  request = objectStore.get(i);\n                  request.onsuccess = /*#__PURE__*/function () {\n                    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(event) {\n                      var result, transformer;\n                      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                        while (1) switch (_context3.prev = _context3.next) {\n                          case 0:\n                            result = event.target.result;\n                            if (result) {\n                              transformer = type === \"form-data\" ? new _transformer.FormDataTransformer(result) : result;\n                              resolve(type === \"form-data\" ? transformer.transform() : transformer);\n                            } else {\n                              resolve(undefined); // Key not found\n                            }\n                          case 2:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }, _callee3);\n                    }));\n                    return function (_x5) {\n                      return _ref3.apply(this, arguments);\n                    };\n                  }();\n                  request.onerror = function (event) {\n                    reject(new Error(\"Failed to get data from IndexedDB: \" + event.target.error));\n                  };\n                case 6:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }, _callee4);\n          }));\n          return function (_x3, _x4) {\n            return _ref2.apply(this, arguments);\n          };\n        }());\n      } catch (error) {\n        console.error(\"Error accessing IndexedDB\", error);\n        return undefined;\n      }\n    }\n    /**\r\n     * Finds the first record that matches the provided criteria.\r\n     * @param criteria - An object representing the key-value pairs to match against the records.\r\n     * @param type - Optional parameter to specify the return type: \"form-data\" or \"record\".\r\n     * @returns A promise that resolves to the first matching record or `undefined` if no match is found.\r\n     */\n  }, {\n    key: \"readOneBy\",\n    value: (function () {\n      var _readOneBy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(criteria, type) {\n        var objectStore, request;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.prev = 0;\n              _context6.next = 3;\n              return this._getObjectStore(\"readonly\");\n            case 3:\n              objectStore = _context6.sent;\n              request = objectStore.getAll();\n              return _context6.abrupt(\"return\", new Promise(function (resolve, reject) {\n                request.onsuccess = /*#__PURE__*/function () {\n                  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(event) {\n                    var results, matchedResult, transformer;\n                    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                      while (1) switch (_context5.prev = _context5.next) {\n                        case 0:\n                          results = event.target.result;\n                          matchedResult = results.find(function (item) {\n                            return Object.keys(criteria).every(function (key) {\n                              return criteria[key] === item[key];\n                            });\n                          });\n                          if (matchedResult) {\n                            transformer = type === \"form-data\" ? new _transformer.FormDataTransformer(matchedResult) : matchedResult;\n                            resolve(type === \"form-data\" ? transformer.transform() : transformer);\n                          } else {\n                            resolve(undefined); // No match found\n                          }\n                        case 3:\n                        case \"end\":\n                          return _context5.stop();\n                      }\n                    }, _callee5);\n                  }));\n                  return function (_x8) {\n                    return _ref4.apply(this, arguments);\n                  };\n                }();\n                request.onerror = function (event) {\n                  reject(new Error(\"Failed to get data from IndexedDB: \" + event.target.error));\n                };\n              }));\n            case 8:\n              _context6.prev = 8;\n              _context6.t0 = _context6[\"catch\"](0);\n              console.error(\"Error accessing IndexedDB\", _context6.t0);\n              return _context6.abrupt(\"return\", undefined);\n            case 12:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this, [[0, 8]]);\n      }));\n      function readOneBy(_x6, _x7) {\n        return _readOneBy.apply(this, arguments);\n      }\n      return readOneBy;\n    }()\n    /**\r\n     * Retrieves all elements from the IDBObjectStore and returns them as an array.\r\n     * @returns A promise that resolves to an array containing all the elements from the IDBObjectStore.\r\n     */\n    )\n  }, {\n    key: \"read\",\n    value: function read() {\n      var _this2 = this;\n      return new Promise( /*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(resolve, reject) {\n          var objectStore, elements, request;\n          return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n            while (1) switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return _this2._getObjectStore(\"readonly\");\n              case 2:\n                objectStore = _context7.sent;\n                elements = [];\n                request = objectStore.openCursor();\n                request.onerror = function (event) {\n                  reject(\"Erreur lors de la récupération des éléments: \" + event.target.error);\n                };\n                request.onsuccess = function (event) {\n                  var cursor = event.target.result;\n                  if (cursor) {\n                    elements.push(cursor.value);\n                    cursor[\"continue\"]();\n                  } else {\n                    resolve(elements);\n                  }\n                };\n              case 7:\n              case \"end\":\n                return _context7.stop();\n            }\n          }, _callee7);\n        }));\n        return function (_x9, _x10) {\n          return _ref5.apply(this, arguments);\n        };\n      }());\n    }\n    /**\r\n     * Retrieves all elements that match the specified criteria from the IDBObjectStore.\r\n     * @param criteria - An object representing the key-value pairs that the elements must match.\r\n     * @returns A promise that resolves to an array containing all matching elements from the IDBObjectStore.\r\n     */\n  }, {\n    key: \"readBy\",\n    value: function readBy(criteria) {\n      var _this3 = this;\n      return new Promise( /*#__PURE__*/function () {\n        var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(resolve, reject) {\n          var objectStore, elements, request;\n          return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n            while (1) switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return _this3._getObjectStore(\"readonly\");\n              case 2:\n                objectStore = _context8.sent;\n                elements = [];\n                request = objectStore.openCursor();\n                request.onerror = function (event) {\n                  reject(new Error(\"Erreur lors de la récupération des éléments: \" + event.target.error));\n                };\n                request.onsuccess = function (event) {\n                  var cursor = event.target.result;\n                  if (cursor) {\n                    if ((0, _helpers.matchesCriteria)(cursor.value, criteria)) {\n                      elements.push(cursor.value);\n                    }\n                    cursor[\"continue\"]();\n                  } else {\n                    resolve(elements);\n                  }\n                };\n              case 7:\n              case \"end\":\n                return _context8.stop();\n            }\n          }, _callee8);\n        }));\n        return function (_x11, _x12) {\n          return _ref6.apply(this, arguments);\n        };\n      }());\n    }\n\n    /**\r\n     * Updates an element in the database.\r\n     * @param id - The numeric ID of the element to be updated.\r\n     * @param data - The new data to be merged with the existing data.\r\n     * @returns A promise that resolves to a boolean indicating whether the update was successful (true) or the ID was not found (false).\r\n     */\n  }, {\n    key: \"update\",\n    value: (function () {\n      var _update = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(id, data) {\n        var objectStore, request;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              _context10.prev = 0;\n              _context10.next = 3;\n              return this._getObjectStore(\"readwrite\");\n            case 3:\n              objectStore = _context10.sent;\n              request = objectStore.get(id);\n              return _context10.abrupt(\"return\", new Promise(function (resolve, reject) {\n                request.onsuccess = /*#__PURE__*/function () {\n                  var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(event) {\n                    var existingData, updatedData, updateRequest;\n                    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n                      while (1) switch (_context9.prev = _context9.next) {\n                        case 0:\n                          existingData = event.target.result;\n                          if (existingData) {\n                            updatedData = _objectSpread(_objectSpread({}, existingData), data);\n                            updateRequest = objectStore.put(updatedData, id);\n                            updateRequest.onsuccess = function () {\n                              resolve(true);\n                            };\n                            updateRequest.onerror = function (error) {\n                              var _error$target;\n                              reject(new Error(\"Failed to update data in IndexedDB: \" + ((_error$target = error.target) === null || _error$target === void 0 ? void 0 : _error$target.error)));\n                            };\n                          } else {\n                            resolve(false);\n                          }\n                        case 2:\n                        case \"end\":\n                          return _context9.stop();\n                      }\n                    }, _callee9);\n                  }));\n                  return function (_x15) {\n                    return _ref7.apply(this, arguments);\n                  };\n                }();\n                request.onerror = function (event) {\n                  reject(new Error(\"Failed to get data from IndexedDB: \" + event.target.error));\n                };\n              }));\n            case 8:\n              _context10.prev = 8;\n              _context10.t0 = _context10[\"catch\"](0);\n              console.error(\"Error accessing IndexedDB\", _context10.t0);\n              return _context10.abrupt(\"return\", false);\n            case 12:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this, [[0, 8]]);\n      }));\n      function update(_x13, _x14) {\n        return _update.apply(this, arguments);\n      }\n      return update;\n    }()\n    /**\r\n     * Deletes the object from the IDBObjectStore.\r\n     * @param id - The ID of the object to delete.\r\n     */\n    )\n  }, {\n    key: \"deleteOne\",\n    value: (function () {\n      var _deleteOne = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(id, refactoringShortKeyString, callback) {\n        var objectStore;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              _context11.prev = 0;\n              _context11.next = 3;\n              return this._getObjectStore(\"readwrite\");\n            case 3:\n              objectStore = _context11.sent;\n              objectStore[\"delete\"](id);\n              if (!refactoringShortKeyString) {\n                _context11.next = 8;\n                break;\n              }\n              _context11.next = 8;\n              return this.refactorIndexes(refactoringShortKeyString);\n            case 8:\n              if (callback) callback(id);\n              return _context11.abrupt(\"return\", true);\n            case 12:\n              _context11.prev = 12;\n              _context11.t0 = _context11[\"catch\"](0);\n              console.error(\"Error removing file with id:\".concat(id, \": \").concat(_context11.t0));\n              return _context11.abrupt(\"return\", false);\n            case 16:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this, [[0, 12]]);\n      }));\n      function deleteOne(_x16, _x17, _x18) {\n        return _deleteOne.apply(this, arguments);\n      }\n      return deleteOne;\n    }()\n    /**\r\n     * Deletes the specified object store from the IndexedDB database.\r\n     * @returns A promise that resolves if the object store is successfully deleted, or rejects with an error if any error occurs during the operation.\r\n     */\n    )\n  }, {\n    key: \"deleteOS\",\n    value: function deleteOS() {\n      var _this4 = this;\n      return new Promise(function (resolve, reject) {\n        var request = window.indexedDB.open(_this4.dbname, _this4.version);\n        request.onerror = function () {\n          reject(new Error(\"Failed to open database.\"));\n        };\n        request.onupgradeneeded = function (event) {\n          var db = event.target.result;\n          if (db.objectStoreNames.contains(_this4.osname)) {\n            db.deleteObjectStore(_this4.osname);\n          }\n        };\n        request.onsuccess = function () {\n          resolve();\n        };\n      });\n    }\n    /**\r\n     * Clears the entire IndexedDB database by deleting the database.\r\n     */\n  }, {\n    key: \"deleteAll\",\n    value: (function () {\n      var _deleteAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              _context12.next = 2;\n              return this.openDB();\n            case 2:\n              indexedDB.deleteDatabase(this.dbname);\n            case 3:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this);\n      }));\n      function deleteAll() {\n        return _deleteAll.apply(this, arguments);\n      }\n      return deleteAll;\n    }()\n    /**\r\n     * Opens or creates a new IndexedDB database with the specified name and version.\r\n     * @returns A promise that resolves to the opened or created IDBDatabase object.\r\n     */\n    )\n  }, {\n    key: \"openDB\",\n    value: function openDB() {\n      var _this5 = this;\n      return new Promise(function (resolve, reject) {\n        var request = window.indexedDB.open(_this5.dbname, _this5.version);\n        request.onerror = function (event) {\n          var target = event.target;\n          console.error(\"Failed to open database\", target === null || target === void 0 ? void 0 : target.error);\n          reject(target === null || target === void 0 ? void 0 : target.error);\n        };\n        request.onsuccess = function (event) {\n          var _event$target;\n          var db = (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result;\n          resolve(db);\n        };\n        request.onupgradeneeded = function (event) {\n          var _event$target2;\n          var db = (_event$target2 = event.target) === null || _event$target2 === void 0 ? void 0 : _event$target2.result;\n          db.createObjectStore(_this5.osname, {\n            autoIncrement: true\n          });\n        };\n      });\n    }\n    /**\r\n     * Checks if database is empty.\r\n     * @returns A promise that resolves to `true` if database is empty, and `false` otherwise.\r\n     */\n  }, {\n    key: \"_isEmpty\",\n    value: (function () {\n      var _isEmpty2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        var objectStore, countRequest;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              _context13.next = 2;\n              return this._getObjectStore(\"readonly\");\n            case 2:\n              objectStore = _context13.sent;\n              countRequest = objectStore.count();\n              return _context13.abrupt(\"return\", new Promise(function (resolve, reject) {\n                countRequest.onsuccess = function () {\n                  resolve(countRequest.result === 0);\n                };\n                countRequest.onerror = function () {\n                  reject(new Error(\"Failed to count items in IndexedDB\"));\n                };\n              }));\n            case 5:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n      function _isEmpty() {\n        return _isEmpty2.apply(this, arguments);\n      }\n      return _isEmpty;\n    }()\n    /**\r\n     * Retrieves the length of the object store.\r\n     * @returns A promise that resolves with the length of the object store.\r\n     */\n    )\n  }, {\n    key: \"_length\",\n    value: (function () {\n      var _length2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        var objectStore, countRequest;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              _context14.next = 2;\n              return this._getObjectStore(\"readonly\");\n            case 2:\n              objectStore = _context14.sent;\n              countRequest = objectStore.count();\n              return _context14.abrupt(\"return\", new Promise(function (resolve, reject) {\n                countRequest.onsuccess = function (e) {\n                  resolve(countRequest.result);\n                };\n                countRequest.onerror = function (err) {\n                  reject(console.error(\"Error\", err));\n                };\n              }));\n            case 5:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, this);\n      }));\n      function _length() {\n        return _length2.apply(this, arguments);\n      }\n      return _length;\n    }()\n    /**\r\n     * Retrieves the IDBObjectStore with the specified access mode from the opened database.\r\n     * @param access - The access mode for the transaction.\r\n     * @returns A promise that resolves to the IDBObjectStore with the specified access mode.\r\n     */\n    )\n  }, {\n    key: \"_getObjectStore\",\n    value: (function () {\n      var _getObjectStore2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(access) {\n        var db, transaction;\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              _context15.next = 2;\n              return this.openDB();\n            case 2:\n              db = _context15.sent;\n              transaction = db.transaction([this.osname], access);\n              return _context15.abrupt(\"return\", transaction.objectStore(this.osname));\n            case 5:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee15, this);\n      }));\n      function _getObjectStore(_x19) {\n        return _getObjectStore2.apply(this, arguments);\n      }\n      return _getObjectStore;\n    }()\n    /**\r\n     * Refactors the indexes of the indexed data.\r\n     * @param refactoringShortKeyString - The string to be used for refactoring the indexes.\r\n     */\n    )\n  }, {\n    key: \"refactorIndexes\",\n    value: (function () {\n      var _refactorIndexes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(refactoringShortKeyString) {\n        var _this6 = this;\n        var objectData, isEmpty, updatedObjectArray;\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              _context17.next = 2;\n              return this.read();\n            case 2:\n              objectData = _context17.sent;\n              _context17.next = 5;\n              return this._isEmpty();\n            case 5:\n              isEmpty = _context17.sent;\n              updatedObjectArray = [];\n              if (!isEmpty) {\n                _context17.next = 9;\n                break;\n              }\n              return _context17.abrupt(\"return\", null);\n            case 9:\n              objectData.forEach( /*#__PURE__*/function () {\n                var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(object, i) {\n                  var updatedObject;\n                  return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n                    while (1) switch (_context16.prev = _context16.next) {\n                      case 0:\n                        updatedObject = _this6.processObject(object, i, objectData.length, refactoringShortKeyString);\n                        updatedObjectArray.push(updatedObject);\n                      case 2:\n                      case \"end\":\n                        return _context16.stop();\n                    }\n                  }, _callee16);\n                }));\n                return function (_x21, _x22) {\n                  return _ref8.apply(this, arguments);\n                };\n              }());\n              this.refactor(updatedObjectArray);\n            case 11:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee17, this);\n      }));\n      function refactorIndexes(_x20) {\n        return _refactorIndexes.apply(this, arguments);\n      }\n      return refactorIndexes;\n    }()\n    /**\r\n     * Replaces the indexed data in the object store.\r\n     * This method opens the indexedDB, clears the existing data in the object store, and adds the new data from the provided array.\r\n     * @param object - The array of data to replace the indexed data with.\r\n     */\n    )\n  }, {\n    key: \"refactor\",\n    value: function refactor(object) {\n      var _this7 = this;\n      var openDBRequest = indexedDB.open(this.dbname, this.version);\n      openDBRequest.onsuccess = function (event) {\n        var IBDB = event.target.result;\n        var result = IBDB;\n        var transaction = result.transaction([_this7.osname], \"readwrite\");\n        var objetsStore = transaction.objectStore(_this7.osname);\n        var clear = objetsStore.clear();\n        clear.onsuccess = function () {\n          object.forEach(function (data) {\n            var addRequest = objetsStore.add(data);\n            addRequest.onsuccess = function (event) {\n              if (event.target) {\n                var elementId = event.target.result;\n                var elementObject = data;\n                elementObject[\"@id\"] = elementId;\n                objetsStore.put(elementObject, elementId);\n              }\n            };\n          });\n        };\n        clear.onerror = function (event) {\n          console.error(\"Erreur lors de la suppression des données existantes :\", event.target.error);\n        };\n      };\n      openDBRequest.onerror = function (event) {\n        console.error(\"Erreur lors de l'ouverture de la base de données :\", event.target.error);\n      };\n    }\n    /**\r\n     * Processes an object to update its keys.\r\n     * @param object - The object to be processed.\r\n     * @param i - The index value used for updating the keys.\r\n     * @param length - The length of the object.\r\n     * @param refactoringShortKeyString - The string used for splitting the keys.\r\n     * @returns The processed object with updated keys.\r\n     */\n  }, {\n    key: \"processObject\",\n    value: function processObject(object, i, length, refactoringShortKeyString) {\n      var newObject = {};\n      var base64String, id, _token, tokenKey;\n      for (var key in object) {\n        if (Object.prototype.hasOwnProperty.call(object, key)) {\n          var keyParts = refactoringShortKeyString ? key.split(refactoringShortKeyString) : null;\n          var keyPart = keyParts ? keyParts[1] : null;\n          _token = (0, _helpers.hasKeyWithNameSubstring)(object, \"token\");\n          if (null !== _token) {\n            tokenKey = (0, _helpers.hasKeyWithNameSubstring)(object, \"token\", true);\n          }\n          if (\"@base64String\" === key) {\n            base64String = object[key];\n          }\n          if (\"@id\" === key) {\n            id = parseInt(object[key]);\n          }\n          if (keyPart) {\n            var findchar = (0, _helpers.findChar)(keyPart, length);\n            var _char = findchar !== null && findchar !== void 0 ? findchar : \"0\";\n            var newKeyPart = keyPart.replace(\"[\".concat(_char, \"]\"), \"[\".concat(i.toString(), \"]\"));\n            var newKey = \"\".concat(keyParts[0]).concat(refactoringShortKeyString).concat(newKeyPart);\n            newObject[newKey] = object[key];\n          }\n        }\n      }\n      if (base64String) newObject[\"@base64String\"] = base64String;\n      newObject[\"@id\"] = id;\n      if (_token) newObject[\"\".concat(tokenKey)] = _token;\n      return newObject;\n    }\n  }]);\n  return TempData;\n}();\n\n//# sourceURL=webpack://@easylibs/easylibs/./packages/tempdata/src/tempdata.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _tempdata = _interopRequireDefault(__webpack_require__(/*! ../packages/tempdata/src/tempdata */ \"./packages/tempdata/src/tempdata.ts\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar tempdata = new _tempdata[\"default\"](\"test\", \"mydata\", 2);\nvar data0 = {\n  firstname: 'Alain',\n  lastname: 'MBA NDONG',\n  age: 17,\n  job: 'student',\n  country: 'Gabon',\n  sex: 'male'\n};\nvar data1 = {\n  firstname: 'Sarah Elise',\n  lastname: 'OBONE MVOU',\n  age: 30,\n  job: 'journalist',\n  country: 'Gabon',\n  sex: 'female'\n};\nvar data3 = {\n  firstname: 'Melissa Anita',\n  lastname: 'KPWEYA',\n  age: 25,\n  job: 'student',\n  country: 'Togo',\n  sex: 'female'\n};\nvar data2 = {\n  firstname: 'Guy Bertrant',\n  lastname: 'MABIALA MABIALA',\n  age: 25,\n  job: 'taxi driver',\n  country: 'RDC',\n  sex: \"male\"\n};\n//tempdata.add(data3); // Adds one data object or...\n//tempdata.add([data1, data2]); // Adds both objects to the database in a single transaction\n// tempdata.read().then((data)=>{\n//     console.log(data)\n// })\n// tempdata.readOne(1).then((data)=>{\n//     console.log(data)\n// })\n// tempdata.readOneBy({age:25,sex:'female'}).then((data)=>{\n//     console.log(data)\n// })\ntempdata.readBy({\n  age: 25\n}).then(function (data) {\n  console.log(data);\n});\n\n//# sourceURL=webpack://@easylibs/easylibs/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});