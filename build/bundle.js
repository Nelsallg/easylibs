/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./packages/tempdata/src/script/backend.ts":
/*!*************************************************!*\
  !*** ./packages/tempdata/src/script/backend.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _fetchRequest = _interopRequireDefault(__webpack_require__(/*! @easylibs/fetch-request */ \"./packages/fetch-request/dist/fetch-request.js\"));\nvar _transformer = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module './transformer'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar Backend = exports[\"default\"] = /*#__PURE__*/function () {\n  /**\r\n   * @param database - base de données\r\n   * @param uri - L'URL de destination où les données du formulaire seront envoyées.\r\n   */\n  function Backend(database, uri) {\n    _classCallCheck(this, Backend);\n    _defineProperty(this, \"_response\", null);\n    this._database = database;\n    this._uri = uri;\n  }\n  /**\r\n   * Persists data to the server.\r\n   *\r\n   * @param redirectURL - The URL to redirect to after the data is persisted.\r\n   * @param callback - The callback function to be called after the data is persisted.\r\n   * @returns A promise that resolves when the data is persisted.\r\n   */\n  _createClass(Backend, [{\n    key: \"persist\",\n    value: (function () {\n      var _persist = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(redirectURL) {\n        var _this = this;\n        var callback,\n          promises,\n          formData,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              callback = _args.length > 1 && _args[1] !== undefined ? _args[1] : function (result) {};\n              _context.next = 3;\n              return this.getIndexedData();\n            case 3:\n              promises = _context.sent;\n              _context.t0 = this;\n              _context.next = 7;\n              return Promise.all(promises);\n            case 7:\n              _context.t1 = _context.sent;\n              formData = _context.t0.normalizeArrayField.call(_context.t0, _context.t1);\n              new _fetchRequest[\"default\"]({\n                uri: this._uri,\n                data: formData,\n                options: {\n                  method: \"POST\",\n                  acceptDataFormat: \"form-data\"\n                },\n                callbacks: {\n                  onPostFetch: function onPostFetch(result) {\n                    _this._response = result;\n                    callback(_this._response);\n                    if (redirectURL && _this._response && _this._response.success) {\n                      return window.location.href = redirectURL || \"/\";\n                    }\n                    return _this._response;\n                  }\n                }\n              });\n            case 10:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function persist(_x) {\n        return _persist.apply(this, arguments);\n      }\n      return persist;\n    }()\n    /**\r\n     * Saves data to the server.\r\n     * @param options - The options containing the submiter, callback, redirectUrl, and loader properties.\r\n     */\n    )\n  }, {\n    key: \"save\",\n    value: function save(options) {\n      var _ref,\n        _this2 = this;\n      var form = (_ref = options.submiter.closest(\"form\")) !== null && _ref !== void 0 ? _ref : document.querySelector(\"form\");\n      options.submiter.addEventListener(\"click\", /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(e) {\n          var isEmpty, innerSubmiter, formData;\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                e.preventDefault();\n                _context2.next = 3;\n                return _this2._database._isEmpty();\n              case 3:\n                isEmpty = _context2.sent;\n                if (!(true === isEmpty && !form.checkValidity())) {\n                  _context2.next = 6;\n                  break;\n                }\n                return _context2.abrupt(\"return\", form.reportValidity());\n              case 6:\n                innerSubmiter = _this2.escape(options.submiter.innerHTML);\n                if (options.loader) {\n                  options.submiter.innerHTML = options.loader;\n                }\n                //if the data does not come from the indexed database\n                if (!(true === isEmpty && form.checkValidity())) {\n                  _context2.next = 13;\n                  break;\n                }\n                formData = new FormData(form);\n                if (options.preSave) {\n                  options.preSave(formData);\n                }\n                new _fetchRequest[\"default\"]({\n                  uri: _this2._uri,\n                  data: formData,\n                  options: {\n                    method: \"POST\",\n                    acceptDataFormat: \"form-data\",\n                    responseType: options.responseType\n                  },\n                  callbacks: {\n                    onPostFetch: function onPostFetch(response, status) {\n                      options.submiter.innerHTML = innerSubmiter;\n                      if (options.redirectUrl && status === 200) {\n                        options.callback(response);\n                        return window.location.href = options.redirectUrl;\n                      }\n                      return options.callback(response);\n                    }\n                  }\n                });\n                return _context2.abrupt(\"return\");\n              case 13:\n                //If the data come from the indexed database\n                form.setAttribute(\"novalidate\", \"\");\n                _context2.next = 16;\n                return _this2.persist(options.redirectUrl, function (response) {\n                  options.submiter.innerHTML = innerSubmiter;\n                  options.callback(response);\n                });\n              case 16:\n              case \"end\":\n                return _context2.stop();\n            }\n          }, _callee2);\n        }));\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n    }\n  }, {\n    key: \"getIndexedData\",\n    value: function () {\n      var _getIndexedData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var elements, promises, i;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return this._database.readAll();\n            case 2:\n              elements = _context4.sent;\n              promises = [];\n              if (elements instanceof Array && elements.length > 0) {\n                for (i = 0; i < elements.length; i++) {\n                  (function (currentIndex) {\n                    promises.push(new Promise( /*#__PURE__*/function () {\n                      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(resolve, reject) {\n                        var data;\n                        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                          while (1) switch (_context3.prev = _context3.next) {\n                            case 0:\n                              try {\n                                data = elements[currentIndex];\n                                if (data) {\n                                  delete data[\"@base64String\"];\n                                  delete data[\"@id\"];\n                                }\n                                resolve(data);\n                              } catch (error) {\n                                reject(\"Sorry, a problem occurred:\" + error);\n                              }\n                            case 1:\n                            case \"end\":\n                              return _context3.stop();\n                          }\n                        }, _callee3);\n                      }));\n                      return function (_x3, _x4) {\n                        return _ref3.apply(this, arguments);\n                      };\n                    }()));\n                  })(i);\n                }\n              }\n              return _context4.abrupt(\"return\", promises);\n            case 6:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function getIndexedData() {\n        return _getIndexedData.apply(this, arguments);\n      }\n      return getIndexedData;\n    }()\n    /**\r\n     * Normalizes an array field into a FormData object.\r\n     * This method takes an array of data objects and normalizes it into a FormData object. It handles files within the data objects by transforming them into Blobs using a BlobTransformer. The resulting FormData object is returned.\r\n     * @param datas - The array of data objects to be normalized.\r\n     * @returns The normalized FormData object.\r\n     */\n  }, {\n    key: \"normalizeArrayField\",\n    value: function normalizeArrayField(datas) {\n      var transformer = new _transformer.BlobTransformer();\n      var index = 0;\n      return datas.reduce(function (result, data) {\n        if (data) {\n          var objectsFormData = Object.keys(data).reduce(function (formData, key) {\n            var files = data[key];\n            if (Array.isArray(files) && files.length > 0) {\n              files.forEach(function (file) {\n                formData.append(key, transformer.fromFile(file), file.name);\n              });\n            } else {\n              formData.set(key, data[key]);\n            }\n            return formData;\n          }, new FormData());\n          objectsFormData.forEach(function (value, key) {\n            result.append(key, value);\n          });\n          index++;\n        }\n        return result;\n      }, new FormData());\n    }\n    /**\r\n     * Retourne la réponse du serveur.\r\n     */\n  }, {\n    key: \"response\",\n    get: function get() {\n      return this._response;\n    }\n    /**\r\n     * A function to escape special characters in a string using the DOM API.\r\n     *\r\n     * @param str - The input string to be escaped.\r\n     * @returns - The escaped string with special characters replaced with their HTML entity equivalents.\r\n     */\n  }, {\n    key: \"escape\",\n    value: function escape(str) {\n      if (!str) {\n        return \"\";\n      }\n      var div = document.createElement(\"div\");\n      div.appendChild(document.createTextNode(str));\n      return div.innerHTML;\n    }\n  }]);\n  return Backend;\n}();\n\n//# sourceURL=webpack://easylibs/./packages/tempdata/src/script/backend.ts?");

/***/ }),

/***/ "./packages/tempdata/src/scripts/transformer.ts":
/*!******************************************************!*\
  !*** ./packages/tempdata/src/scripts/transformer.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.FormDataTransformer = exports.BlobTransformer = void 0;\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar BlobTransformer = exports.BlobTransformer = /*#__PURE__*/function () {\n  function BlobTransformer() {\n    _classCallCheck(this, BlobTransformer);\n  }\n  _createClass(BlobTransformer, [{\n    key: \"fromUint8Array\",\n    value:\n    /**\r\n     * Convertit un tableau Uint8Array en objet Blob.\r\n     * @param uint8Array - Le tableau Uint8Array à convertir en Blob.\r\n     * @param contentType - (Optionnel) Le type de contenu du Blob.\r\n     * @returns Le Blob résultant.\r\n     */\n    function fromUint8Array(uint8Array, contentType) {\n      var _contentType;\n      contentType = (_contentType = contentType) !== null && _contentType !== void 0 ? _contentType : \"\";\n      return new Blob([uint8Array], {\n        type: contentType\n      });\n    }\n    /**\r\n     * Crée un Blob à partir d'un objet File.\r\n     * @param file - Le fichier à convertir en Blob.\r\n     * @returns Le Blob résultant.\r\n     */\n  }, {\n    key: \"fromFile\",\n    value: function fromFile(file) {\n      return file.slice(0, file.size, file.type);\n    }\n    /**\r\n     * Crée un Blob à partir d'une chaîne encodée en base64.\r\n     * @param base64String - La chaîne encodée en base64.\r\n     * @param contentType - (Optionnel) Le type de contenu du Blob.\r\n     * @returns Le Blob résultant.\r\n     */\n  }, {\n    key: \"fromBase64String\",\n    value: function fromBase64String(base64String, contentType) {\n      contentType = contentType || \"\";\n      var byteCharacters = window.atob(base64String.split(\",\")[1]);\n      var byteNumbers = new Array(byteCharacters.length);\n      for (var i = 0; i < byteCharacters.length; i++) {\n        byteNumbers[i] = byteCharacters.charCodeAt(i);\n      }\n      var byteArray = new Uint8Array(byteNumbers);\n      return new Blob([byteArray], {\n        type: contentType\n      });\n    }\n  }]);\n  return BlobTransformer;\n}();\nvar FormDataTransformer = exports.FormDataTransformer = /*#__PURE__*/function () {\n  function FormDataTransformer(data) {\n    _classCallCheck(this, FormDataTransformer);\n    this._data = data;\n  }\n  /**\r\n   * Transforme les données en un objet FormData.\r\n   * @returns L'objet FormData résultant.\r\n   */\n  _createClass(FormDataTransformer, [{\n    key: \"transform\",\n    value: function transform() {\n      var formData = new FormData();\n      if (_typeof(this._data) === \"object\") {\n        var data = this._data;\n        try {\n          for (var key in this._data) {\n            if (this._data.hasOwnProperty(key)) {\n              formData.append(key, data[key]);\n            }\n          }\n        } catch (error) {\n          console.error(\"Erreur détectée: \" + error);\n        }\n      }\n      return formData;\n    }\n  }]);\n  return FormDataTransformer;\n}();\n\n//# sourceURL=webpack://easylibs/./packages/tempdata/src/scripts/transformer.ts?");

/***/ }),

/***/ "./packages/tempdata/src/tempdata.ts":
/*!*******************************************!*\
  !*** ./packages/tempdata/src/tempdata.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _transformer = __webpack_require__(/*! ./scripts/transformer */ \"./packages/tempdata/src/scripts/transformer.ts\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar TempData = exports[\"default\"] = /*#__PURE__*/function () {\n  /**\r\n   * @param dbname - The name of the IndexedDB database to open or create.\r\n   * @param osname - The name of the object (object store) which will contain the elements to be stored\r\n   * @param version - The version of the IndexedDB database (default: 1).\r\n   */\n  function TempData(dbname, osname) {\n    var version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    _classCallCheck(this, TempData);\n    this.dbname = dbname;\n    this.osname = osname;\n    this.version = version;\n  }\n  /**\r\n   * Adds a new element to the IDBObjectStore with the provided object.\r\n   * @param data - Data to add to the IDBObjectStore.\r\n   * @returns A promise that resolves to an object indicating the success of the operation.\r\n   */\n  _createClass(TempData, [{\n    key: \"add\",\n    value: (function () {\n      var _add = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(data) {\n        var objectStore, request;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n              _context2.next = 3;\n              return this._getObjectStore(\"readwrite\");\n            case 3:\n              objectStore = _context2.sent;\n              request = objectStore.add(data);\n              return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n                request.onsuccess = /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(event) {\n                    var elementId, elementObject;\n                    return _regeneratorRuntime().wrap(function _callee$(_context) {\n                      while (1) switch (_context.prev = _context.next) {\n                        case 0:\n                          if (event.target) {\n                            elementId = event.target.result;\n                            elementObject = data;\n                            elementObject[\"@id\"] = elementId;\n                            objectStore.put(elementObject, elementId);\n                            resolve({\n                              success: true,\n                              elementObject: elementObject\n                            });\n                          }\n                        case 1:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }, _callee);\n                  }));\n                  return function (_x2) {\n                    return _ref.apply(this, arguments);\n                  };\n                }();\n                request.onerror = function (event) {\n                  reject(new Error(\"Failed to add file to IndexedDB: \" + event.target.error));\n                };\n              }));\n            case 8:\n              _context2.prev = 8;\n              _context2.t0 = _context2[\"catch\"](0);\n              console.error(\"Error accessing IndexedDB\", _context2.t0);\n              return _context2.abrupt(\"return\", {\n                success: false\n              });\n            case 12:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[0, 8]]);\n      }));\n      function add(_x) {\n        return _add.apply(this, arguments);\n      }\n      return add;\n    }()\n    /**\r\n    * Retrieves the form data at the specified index from the array of object data obtained from `getIndexedData`.\r\n    * @param index - The index of the form data to retrieve.\r\n    * @returns A promise that resolves to the form data at the specified index, or `undefined` if the index is out of range.\r\n    */\n    )\n  }, {\n    key: \"readOne\",\n    value: function readOne(index, dataType) {\n      var _this = this;\n      try {\n        return new Promise( /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(resolve, reject) {\n            var objectStore, request;\n            return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n              while (1) switch (_context4.prev = _context4.next) {\n                case 0:\n                  _context4.next = 2;\n                  return _this._getObjectStore(\"readonly\");\n                case 2:\n                  objectStore = _context4.sent;\n                  request = objectStore.get(index);\n                  request.onsuccess = /*#__PURE__*/function () {\n                    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(event) {\n                      var result, transformer;\n                      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                        while (1) switch (_context3.prev = _context3.next) {\n                          case 0:\n                            result = event.target.result;\n                            if (result) {\n                              transformer = dataType === \"form-data\" ? new _transformer.FormDataTransformer(result) : result;\n                              resolve(dataType === \"form-data\" ? transformer.transform() : transformer);\n                            } else {\n                              resolve(undefined); // Key not found\n                            }\n                          case 2:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }, _callee3);\n                    }));\n                    return function (_x5) {\n                      return _ref3.apply(this, arguments);\n                    };\n                  }();\n                  request.onerror = function (event) {\n                    reject(new Error(\"Failed to get data from IndexedDB: \" + event.target.error));\n                  };\n                case 6:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }, _callee4);\n          }));\n          return function (_x3, _x4) {\n            return _ref2.apply(this, arguments);\n          };\n        }());\n      } catch (error) {\n        console.error(\"Error accessing IndexedDB\", error);\n        return undefined;\n      }\n    }\n    /**\r\n     * Retrieves all elements from the IDBObjectStore and returns them as an array.\r\n     * @returns A promise that resolves to an array containing all the elements from the IDBObjectStore.\r\n     */\n  }, {\n    key: \"readAll\",\n    value: function readAll() {\n      var _this2 = this;\n      return new Promise( /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(resolve, reject) {\n          var objectStore, elements, request;\n          return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n            while (1) switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return _this2._getObjectStore(\"readonly\");\n              case 2:\n                objectStore = _context5.sent;\n                elements = [];\n                request = objectStore.openCursor();\n                request.onerror = function (event) {\n                  reject(\"Erreur lors de la récupération des éléments de l'index\");\n                };\n                request.onsuccess = function (event) {\n                  var cursor = event.target.result;\n                  if (cursor) {\n                    elements.push(cursor.value);\n                    cursor[\"continue\"]();\n                  } else {\n                    resolve(elements);\n                  }\n                };\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }, _callee5);\n        }));\n        return function (_x6, _x7) {\n          return _ref4.apply(this, arguments);\n        };\n      }());\n    }\n    /**\r\n     * Updates an element in the database.\r\n     * @param id - The numeric ID of the element to be updated.\r\n     * @param data - The new data to be merged with the existing data.\r\n     * @returns A promise that resolves to a boolean indicating whether the update was successful (true) or the ID was not found (false).\r\n     */\n  }, {\n    key: \"update\",\n    value: (function () {\n      var _update = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(id, data) {\n        var objectStore, request;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.prev = 0;\n              _context7.next = 3;\n              return this._getObjectStore(\"readwrite\");\n            case 3:\n              objectStore = _context7.sent;\n              request = objectStore.get(id);\n              return _context7.abrupt(\"return\", new Promise(function (resolve, reject) {\n                request.onsuccess = /*#__PURE__*/function () {\n                  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(event) {\n                    var existingData, updatedData, updateRequest;\n                    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n                      while (1) switch (_context6.prev = _context6.next) {\n                        case 0:\n                          existingData = event.target.result;\n                          if (existingData) {\n                            updatedData = _objectSpread(_objectSpread({}, existingData), data);\n                            updateRequest = objectStore.put(updatedData, id);\n                            updateRequest.onsuccess = function () {\n                              resolve(true);\n                            };\n                            updateRequest.onerror = function (error) {\n                              var _error$target;\n                              reject(new Error(\"Failed to update data in IndexedDB: \" + ((_error$target = error.target) === null || _error$target === void 0 ? void 0 : _error$target.error)));\n                            };\n                          } else {\n                            resolve(false);\n                          }\n                        case 2:\n                        case \"end\":\n                          return _context6.stop();\n                      }\n                    }, _callee6);\n                  }));\n                  return function (_x10) {\n                    return _ref5.apply(this, arguments);\n                  };\n                }();\n                request.onerror = function (event) {\n                  reject(new Error(\"Failed to get data from IndexedDB: \" + event.target.error));\n                };\n              }));\n            case 8:\n              _context7.prev = 8;\n              _context7.t0 = _context7[\"catch\"](0);\n              console.error(\"Error accessing IndexedDB\", _context7.t0);\n              return _context7.abrupt(\"return\", false);\n            case 12:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this, [[0, 8]]);\n      }));\n      function update(_x8, _x9) {\n        return _update.apply(this, arguments);\n      }\n      return update;\n    }()\n    /**\r\n     * Deletes the object with the specified ID from the IDBObjectStore.\r\n     * @param id - The ID of the object to delete.\r\n     */\n    )\n  }, {\n    key: \"deleteOne\",\n    value: (function () {\n      var _deleteOne = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(id) {\n        var objectStore, button, card;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              _context8.prev = 0;\n              _context8.next = 3;\n              return this._getObjectStore(\"readwrite\");\n            case 3:\n              objectStore = _context8.sent;\n              objectStore[\"delete\"](id);\n              _context8.next = 7;\n              return this.refactorIndexes(\"[product]\");\n            case 7:\n              button = document.querySelector(\"[temp-delete=\\\"\".concat(id, \"\\\"]\"));\n              card = button === null || button === void 0 ? void 0 : button.closest(\"[temp-item]\");\n              card === null || card === void 0 || card.remove();\n              return _context8.abrupt(\"return\", true);\n            case 13:\n              _context8.prev = 13;\n              _context8.t0 = _context8[\"catch\"](0);\n              alert(\"Error removing file \".concat(id, \": \").concat(_context8.t0));\n              return _context8.abrupt(\"return\", false);\n            case 17:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this, [[0, 13]]);\n      }));\n      function deleteOne(_x11) {\n        return _deleteOne.apply(this, arguments);\n      }\n      return deleteOne;\n    }()\n    /**\r\n    * Deletes the specified object store from the IndexedDB database.\r\n    * @returns A promise that resolves if the object store is successfully deleted, or rejects with an error if any error occurs during the operation.\r\n    */\n    )\n  }, {\n    key: \"deleteOS\",\n    value: function deleteOS() {\n      var _this3 = this;\n      return new Promise(function (resolve, reject) {\n        var request = window.indexedDB.open(_this3.dbname, _this3.version + 1);\n        request.onerror = function () {\n          reject(new Error(\"Failed to open database.\"));\n        };\n        request.onupgradeneeded = function (event) {\n          var db = event.target.result;\n          if (db.objectStoreNames.contains(_this3.osname)) {\n            db.deleteObjectStore(_this3.osname);\n          }\n        };\n        request.onsuccess = function () {\n          resolve();\n        };\n      });\n    }\n    /**\r\n    * Clears the entire IndexedDB database by deleting the database.\r\n    */\n  }, {\n    key: \"deleteAll\",\n    value: (function () {\n      var _deleteAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              _context9.next = 2;\n              return this.openDB();\n            case 2:\n              indexedDB.deleteDatabase(this.dbname);\n            case 3:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n      function deleteAll() {\n        return _deleteAll.apply(this, arguments);\n      }\n      return deleteAll;\n    }()\n    /**\r\n     * Opens or creates a new IndexedDB database with the specified name and version.\r\n     * @returns A promise that resolves to the opened or created IDBDatabase object.\r\n     */\n    )\n  }, {\n    key: \"openDB\",\n    value: function openDB() {\n      var _this4 = this;\n      return new Promise(function (resolve, reject) {\n        var request = window.indexedDB.open(_this4.dbname, _this4.version);\n        request.onerror = function (event) {\n          var target = event.target;\n          console.error(\"Failed to open database\", target === null || target === void 0 ? void 0 : target.error);\n          reject(target === null || target === void 0 ? void 0 : target.error);\n        };\n        request.onsuccess = function (event) {\n          var _event$target;\n          var db = (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result;\n          resolve(db);\n        };\n        request.onupgradeneeded = function (event) {\n          var _event$target2;\n          var db = (_event$target2 = event.target) === null || _event$target2 === void 0 ? void 0 : _event$target2.result;\n          db.createObjectStore(_this4.osname, {\n            autoIncrement: true\n          });\n        };\n      });\n    }\n    /**\r\n     * Checks if the array of elements obtained from `getIndexedData` is empty.\r\n     * @returns A promise that resolves to `true` if the array is empty, and `false` otherwise.\r\n     */\n  }, {\n    key: \"_isEmpty\",\n    value: (function () {\n      var _isEmpty2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var objectStore, countRequest;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              _context10.next = 2;\n              return this._getObjectStore(\"readonly\");\n            case 2:\n              objectStore = _context10.sent;\n              countRequest = objectStore.count();\n              return _context10.abrupt(\"return\", new Promise(function (resolve, reject) {\n                countRequest.onsuccess = function () {\n                  resolve(countRequest.result === 0);\n                };\n                countRequest.onerror = function () {\n                  reject(new Error(\"Failed to count items in IndexedDB\"));\n                };\n              }));\n            case 5:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n      function _isEmpty() {\n        return _isEmpty2.apply(this, arguments);\n      }\n      return _isEmpty;\n    }()\n    /**\r\n     * Retrieves the length of the object store.\r\n     * This method asynchronously retrieves the length of the object store by performing a count operation.\r\n     * @returns A promise that resolves with the length of the object store.\r\n     */\n    )\n  }, {\n    key: \"_length\",\n    value: (function () {\n      var _length2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var objectStore, countRequest;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              _context11.next = 2;\n              return this._getObjectStore(\"readonly\");\n            case 2:\n              objectStore = _context11.sent;\n              countRequest = objectStore.count();\n              return _context11.abrupt(\"return\", new Promise(function (resolve, reject) {\n                countRequest.onsuccess = function (e) {\n                  resolve(countRequest.result);\n                };\n                countRequest.onerror = function (err) {\n                  reject(console.error(\"Error\", err));\n                };\n              }));\n            case 5:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n      function _length() {\n        return _length2.apply(this, arguments);\n      }\n      return _length;\n    }()\n    /**\r\n     * Retrieves the IDBObjectStore with the specified access mode from the opened database.\r\n     * @param access - The access mode for the transaction.\r\n     * @returns A promise that resolves to the IDBObjectStore with the specified access mode.\r\n     */\n    )\n  }, {\n    key: \"_getObjectStore\",\n    value: (function () {\n      var _getObjectStore2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(access) {\n        var db, transaction;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              _context12.next = 2;\n              return this.openDB();\n            case 2:\n              db = _context12.sent;\n              transaction = db.transaction([this.osname], access);\n              return _context12.abrupt(\"return\", transaction.objectStore(this.osname));\n            case 5:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this);\n      }));\n      function _getObjectStore(_x12) {\n        return _getObjectStore2.apply(this, arguments);\n      }\n      return _getObjectStore;\n    }()\n    /**\r\n     * Refactors the indexes of the indexed data based on the provided string.\r\n     * This method retrieves the indexed data, checks if it is empty, and then processes each object to update the indexes based on the provided string. The refactored data is then replaced in the object store.\r\n     * @param stringBeforeExistingKey - The string to be used for refactoring the indexes.\r\n     */\n    )\n  }, {\n    key: \"refactorIndexes\",\n    value: (function () {\n      var _refactorIndexes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(stringBeforeExistingKey) {\n        var _this5 = this;\n        var objectData, isEmpty, newRefactoredObject;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              _context14.next = 2;\n              return this.readAll();\n            case 2:\n              objectData = _context14.sent;\n              _context14.next = 5;\n              return this._isEmpty();\n            case 5:\n              isEmpty = _context14.sent;\n              newRefactoredObject = [];\n              if (!isEmpty) {\n                _context14.next = 9;\n                break;\n              }\n              return _context14.abrupt(\"return\", null);\n            case 9:\n              objectData.forEach( /*#__PURE__*/function () {\n                var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(object, i) {\n                  var updatedObject;\n                  return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n                    while (1) switch (_context13.prev = _context13.next) {\n                      case 0:\n                        updatedObject = _this5.processObject(object, i, stringBeforeExistingKey, objectData.length);\n                        newRefactoredObject.push(updatedObject);\n                      case 2:\n                      case \"end\":\n                        return _context13.stop();\n                    }\n                  }, _callee13);\n                }));\n                return function (_x14, _x15) {\n                  return _ref6.apply(this, arguments);\n                };\n              }());\n              this.replaceIndexedData(newRefactoredObject);\n            case 11:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, this);\n      }));\n      function refactorIndexes(_x13) {\n        return _refactorIndexes.apply(this, arguments);\n      }\n      return refactorIndexes;\n    }()\n    /**\r\n     * Replaces the indexed data in the object store with the provided data array.\r\n     * This method opens the indexedDB, clears the existing data in the object store, and adds the new data from the provided array.\r\n     * @param object - The array of data to replace the indexed data with.\r\n     */\n    )\n  }, {\n    key: \"replaceIndexedData\",\n    value: function replaceIndexedData(object) {\n      var _this6 = this;\n      var openDBRequest = indexedDB.open(this.dbname, this.version);\n      openDBRequest.onsuccess = function (event) {\n        var IBDB = event.target.result;\n        var result = IBDB;\n        var transaction = result.transaction([_this6.osname], \"readwrite\");\n        var objetsStore = transaction.objectStore(_this6.osname);\n        var clear = objetsStore.clear();\n        clear.onsuccess = function () {\n          object.forEach(function (data) {\n            var addRequest = objetsStore.add(data);\n            // addRequest.onsuccess = (event: any) => {\n            //   if (event.target) {\n            //     const elementId = event.target.result;\n            //     let elementObject = data as any;\n            //     elementObject.id = elementId;\n            //     objetsStore.put(elementObject, elementId);\n            //   }\n            // };\n          });\n        };\n        clear.onerror = function (event) {\n          console.error(\"Erreur lors de la suppression des données existantes :\", event.target.error);\n        };\n      };\n      openDBRequest.onerror = function (event) {\n        console.error(\"Erreur lors de l'ouverture de la base de données :\", event.target.error);\n      };\n    }\n    /**\r\n     * Processes an object to update its keys based on the provided string and index.\r\n     * This method takes an object, splits its keys based on the provided string, and updates the keys with the index value. It also extracts the values of \"base64String\" and \"id\" keys. The processed object with updated keys is returned.\r\n     * @param object - The object to be processed.\r\n     * @param i - The index value used for updating the keys.\r\n     * @param stringBeforeExistingKey - The string used for splitting the keys.\r\n     * @param length - The length of the object.\r\n     * @returns The processed object with updated keys.\r\n     */\n  }, {\n    key: \"processObject\",\n    value: function processObject(object, i, stringBeforeExistingKey, length) {\n      var newObject = {};\n      var base64String = \"\";\n      var id = 0;\n      var _token = \"\";\n      var tokenKey = \"\";\n      for (var key in object) {\n        if (Object.prototype.hasOwnProperty.call(object, key)) {\n          var keyParts = key.split(stringBeforeExistingKey);\n          var keyPart = keyParts[1];\n          _token = this.hasKeyWithNameSubstring(object, \"token\");\n          if (null !== _token) {\n            tokenKey = this.hasKeyWithNameSubstring(object, \"token\", true);\n          }\n          if (\"@base64String\" === key) {\n            base64String = object[key];\n          }\n          if (\"@id\" === key) {\n            id = parseInt(object[key]);\n          }\n          if (keyPart) {\n            var findchar = this.findChar(keyPart, length);\n            var _char = findchar !== null && findchar !== void 0 ? findchar : \"0\";\n            var newKeyPart = keyPart.replace(\"[\".concat(_char, \"]\"), \"[\".concat(i.toString(), \"]\"));\n            var newKey = \"\".concat(keyParts[0]).concat(stringBeforeExistingKey).concat(newKeyPart);\n            newObject[newKey] = object[key];\n          }\n        }\n      }\n      newObject[\"@base64String\"] = base64String;\n      newObject[\"@id\"] = id;\n      newObject[\"\".concat(tokenKey)] = _token;\n      return newObject;\n    }\n  }, {\n    key: \"hasKeyWithNameSubstring\",\n    value: function hasKeyWithNameSubstring(object, substring, getKey) {\n      for (var key in object) {\n        if (key.includes(substring)) {\n          if (undefined === getKey || false === getKey) {\n            return object[key];\n          }\n          if (true === getKey) {\n            return key;\n          }\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"findChar\",\n    value: function findChar(string, limit) {\n      var returnBool = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      for (var i = 0; i <= limit; i++) {\n        var index = string.indexOf(i.toString());\n        if (index !== -1) {\n          return returnBool ? true : i.toString();\n        }\n      }\n      return returnBool ? false : null;\n    }\n  }]);\n  return TempData;\n}();\n\n//# sourceURL=webpack://easylibs/./packages/tempdata/src/tempdata.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _tempdata = _interopRequireDefault(__webpack_require__(/*! ../packages/tempdata/src/tempdata */ \"./packages/tempdata/src/tempdata.ts\"));\nvar _backend = _interopRequireDefault(__webpack_require__(/*! ../packages/tempdata/src/script/backend */ \"./packages/tempdata/src/script/backend.ts\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar tempdata = new _tempdata[\"default\"](\"test\", \"test_data\");\ntempdata.add({\n  firstname: \"Sarah Elise\",\n  lastname: \"OBONE MBA\",\n  age: 18,\n  gender: \"female\",\n  job: \"Student\"\n});\n// tempdata.deleteAll();\nvar backend = new _backend[\"default\"](tempdata, \"http://localhost:8000/src/backend.php\");\nbackend.persist(undefined, function (data) {\n  console.log(data);\n});\n\n//# sourceURL=webpack://easylibs/./src/index.ts?");

/***/ }),

/***/ "./packages/fetch-request/dist/fetch-request.js":
/*!******************************************************!*\
  !*** ./packages/fetch-request/dist/fetch-request.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nfunction _typeof2(o) { \"@babel/helpers - typeof\"; return _typeof2 = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof2(o); }\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (( false ? 0 : _typeof2(exports)) === 'object' && ( false ? 0 : _typeof2(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}\n})(self, function () {\n  return /******/function () {\n    // webpackBootstrap\n    /******/\n    \"use strict\";\n\n    /******/ // The require scope\n    /******/\n    var __nested_webpack_require_1014__ = {};\n    /******/\n    /************************************************************************/\n    /******/ /* webpack/runtime/define property getters */\n    /******/\n    (function () {\n      /******/ // define getter functions for harmony exports\n      /******/__nested_webpack_require_1014__.d = function (exports, definition) {\n        /******/for (var key in definition) {\n          /******/if (__nested_webpack_require_1014__.o(definition, key) && !__nested_webpack_require_1014__.o(exports, key)) {\n            /******/Object.defineProperty(exports, key, {\n              enumerable: true,\n              get: definition[key]\n            });\n            /******/\n          }\n          /******/\n        }\n        /******/\n      };\n      /******/\n    })();\n    /******/\n    /******/ /* webpack/runtime/hasOwnProperty shorthand */\n    /******/\n    (function () {\n      /******/__nested_webpack_require_1014__.o = function (obj, prop) {\n        return Object.prototype.hasOwnProperty.call(obj, prop);\n      };\n      /******/\n    })();\n    /******/\n    /******/ /* webpack/runtime/make namespace object */\n    /******/\n    (function () {\n      /******/ // define __esModule on exports\n      /******/__nested_webpack_require_1014__.r = function (exports) {\n        /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n          /******/Object.defineProperty(exports, Symbol.toStringTag, {\n            value: 'Module'\n          });\n          /******/\n        }\n        /******/\n        Object.defineProperty(exports, '__esModule', {\n          value: true\n        });\n        /******/\n      };\n      /******/\n    })();\n    /******/\n    /************************************************************************/\n    var __nested_webpack_exports__ = {};\n    /*!******************************!*\\\n      !*** ./src/fetch-request.ts ***!\n      \\******************************/\n    __nested_webpack_require_1014__.r(__nested_webpack_exports__);\n    /* harmony export */\n    __nested_webpack_require_1014__.d(__nested_webpack_exports__, {\n      /* harmony export */\"default\": function _default() {\n        return /* binding */FetchRequest;\n      }\n      /* harmony export */\n    });\n    function _typeof(o) {\n      \"@babel/helpers - typeof\";\n\n      return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n        return typeof o;\n      } : function (o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n      }, _typeof(o);\n    }\n    function _slicedToArray(arr, i) {\n      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n    }\n    function _nonIterableRest() {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    function _iterableToArrayLimit(r, l) {\n      var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n      if (null != t) {\n        var e,\n          n,\n          i,\n          u,\n          a = [],\n          f = !0,\n          o = !1;\n        try {\n          if (i = (t = t.call(r)).next, 0 === l) {\n            if (Object(t) !== t) return;\n            f = !1;\n          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n          o = !0, n = r;\n        } finally {\n          try {\n            if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n          } finally {\n            if (o) throw n;\n          }\n        }\n        return a;\n      }\n    }\n    function _arrayWithHoles(arr) {\n      if (Array.isArray(arr)) return arr;\n    }\n    function _createForOfIteratorHelper(o, allowArrayLike) {\n      var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n      if (!it) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n          if (it) o = it;\n          var i = 0;\n          var F = function F() {};\n          return {\n            s: F,\n            n: function n() {\n              if (i >= o.length) return {\n                done: true\n              };\n              return {\n                done: false,\n                value: o[i++]\n              };\n            },\n            e: function e(_e) {\n              throw _e;\n            },\n            f: F\n          };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }\n      var normalCompletion = true,\n        didErr = false,\n        err;\n      return {\n        s: function s() {\n          it = it.call(o);\n        },\n        n: function n() {\n          var step = it.next();\n          normalCompletion = step.done;\n          return step;\n        },\n        e: function e(_e2) {\n          didErr = true;\n          err = _e2;\n        },\n        f: function f() {\n          try {\n            if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n          } finally {\n            if (didErr) throw err;\n          }\n        }\n      };\n    }\n    function _unsupportedIterableToArray(o, minLen) {\n      if (!o) return;\n      if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n      var n = Object.prototype.toString.call(o).slice(8, -1);\n      if (n === \"Object\" && o.constructor) n = o.constructor.name;\n      if (n === \"Map\" || n === \"Set\") return Array.from(o);\n      if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n    }\n    function _arrayLikeToArray(arr, len) {\n      if (len == null || len > arr.length) len = arr.length;\n      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n      return arr2;\n    }\n    function _regeneratorRuntime() {\n      \"use strict\";\n\n      /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */\n      _regeneratorRuntime = function _regeneratorRuntime() {\n        return e;\n      };\n      var t,\n        e = {},\n        r = Object.prototype,\n        n = r.hasOwnProperty,\n        o = Object.defineProperty || function (t, e, r) {\n          t[e] = r.value;\n        },\n        i = \"function\" == typeof Symbol ? Symbol : {},\n        a = i.iterator || \"@@iterator\",\n        c = i.asyncIterator || \"@@asyncIterator\",\n        u = i.toStringTag || \"@@toStringTag\";\n      function define(t, e, r) {\n        return Object.defineProperty(t, e, {\n          value: r,\n          enumerable: !0,\n          configurable: !0,\n          writable: !0\n        }), t[e];\n      }\n      try {\n        define({}, \"\");\n      } catch (t) {\n        define = function define(t, e, r) {\n          return t[e] = r;\n        };\n      }\n      function wrap(t, e, r, n) {\n        var i = e && e.prototype instanceof Generator ? e : Generator,\n          a = Object.create(i.prototype),\n          c = new Context(n || []);\n        return o(a, \"_invoke\", {\n          value: makeInvokeMethod(t, r, c)\n        }), a;\n      }\n      function tryCatch(t, e, r) {\n        try {\n          return {\n            type: \"normal\",\n            arg: t.call(e, r)\n          };\n        } catch (t) {\n          return {\n            type: \"throw\",\n            arg: t\n          };\n        }\n      }\n      e.wrap = wrap;\n      var h = \"suspendedStart\",\n        l = \"suspendedYield\",\n        f = \"executing\",\n        s = \"completed\",\n        y = {};\n      function Generator() {}\n      function GeneratorFunction() {}\n      function GeneratorFunctionPrototype() {}\n      var p = {};\n      define(p, a, function () {\n        return this;\n      });\n      var d = Object.getPrototypeOf,\n        v = d && d(d(values([])));\n      v && v !== r && n.call(v, a) && (p = v);\n      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);\n      function defineIteratorMethods(t) {\n        [\"next\", \"throw\", \"return\"].forEach(function (e) {\n          define(t, e, function (t) {\n            return this._invoke(e, t);\n          });\n        });\n      }\n      function AsyncIterator(t, e) {\n        function invoke(r, o, i, a) {\n          var c = tryCatch(t[r], t, o);\n          if (\"throw\" !== c.type) {\n            var u = c.arg,\n              h = u.value;\n            return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) {\n              invoke(\"next\", t, i, a);\n            }, function (t) {\n              invoke(\"throw\", t, i, a);\n            }) : e.resolve(h).then(function (t) {\n              u.value = t, i(u);\n            }, function (t) {\n              return invoke(\"throw\", t, i, a);\n            });\n          }\n          a(c.arg);\n        }\n        var r;\n        o(this, \"_invoke\", {\n          value: function value(t, n) {\n            function callInvokeWithMethodAndArg() {\n              return new e(function (e, r) {\n                invoke(t, n, e, r);\n              });\n            }\n            return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n          }\n        });\n      }\n      function makeInvokeMethod(e, r, n) {\n        var o = h;\n        return function (i, a) {\n          if (o === f) throw new Error(\"Generator is already running\");\n          if (o === s) {\n            if (\"throw\" === i) throw a;\n            return {\n              value: t,\n              done: !0\n            };\n          }\n          for (n.method = i, n.arg = a;;) {\n            var c = n.delegate;\n            if (c) {\n              var u = maybeInvokeDelegate(c, n);\n              if (u) {\n                if (u === y) continue;\n                return u;\n              }\n            }\n            if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) {\n              if (o === h) throw o = s, n.arg;\n              n.dispatchException(n.arg);\n            } else \"return\" === n.method && n.abrupt(\"return\", n.arg);\n            o = f;\n            var p = tryCatch(e, r, n);\n            if (\"normal\" === p.type) {\n              if (o = n.done ? s : l, p.arg === y) continue;\n              return {\n                value: p.arg,\n                done: n.done\n              };\n            }\n            \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg);\n          }\n        };\n      }\n      function maybeInvokeDelegate(e, r) {\n        var n = r.method,\n          o = e.iterator[n];\n        if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y;\n        var i = tryCatch(o, e.iterator, r.arg);\n        if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y;\n        var a = i.arg;\n        return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y);\n      }\n      function pushTryEntry(t) {\n        var e = {\n          tryLoc: t[0]\n        };\n        1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);\n      }\n      function resetTryEntry(t) {\n        var e = t.completion || {};\n        e.type = \"normal\", delete e.arg, t.completion = e;\n      }\n      function Context(t) {\n        this.tryEntries = [{\n          tryLoc: \"root\"\n        }], t.forEach(pushTryEntry, this), this.reset(!0);\n      }\n      function values(e) {\n        if (e || \"\" === e) {\n          var r = e[a];\n          if (r) return r.call(e);\n          if (\"function\" == typeof e.next) return e;\n          if (!isNaN(e.length)) {\n            var o = -1,\n              i = function next() {\n                for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;\n                return next.value = t, next.done = !0, next;\n              };\n            return i.next = i;\n          }\n        }\n        throw new TypeError(_typeof(e) + \" is not iterable\");\n      }\n      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", {\n        value: GeneratorFunctionPrototype,\n        configurable: !0\n      }), o(GeneratorFunctionPrototype, \"constructor\", {\n        value: GeneratorFunction,\n        configurable: !0\n      }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) {\n        var e = \"function\" == typeof t && t.constructor;\n        return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name));\n      }, e.mark = function (t) {\n        return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t;\n      }, e.awrap = function (t) {\n        return {\n          __await: t\n        };\n      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {\n        return this;\n      }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {\n        void 0 === i && (i = Promise);\n        var a = new AsyncIterator(wrap(t, r, n, o), i);\n        return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {\n          return t.done ? t.value : a.next();\n        });\n      }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () {\n        return this;\n      }), define(g, \"toString\", function () {\n        return \"[object Generator]\";\n      }), e.keys = function (t) {\n        var e = Object(t),\n          r = [];\n        for (var n in e) r.push(n);\n        return r.reverse(), function next() {\n          for (; r.length;) {\n            var t = r.pop();\n            if (t in e) return next.value = t, next.done = !1, next;\n          }\n          return next.done = !0, next;\n        };\n      }, e.values = values, Context.prototype = {\n        constructor: Context,\n        reset: function reset(e) {\n          if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);\n        },\n        stop: function stop() {\n          this.done = !0;\n          var t = this.tryEntries[0].completion;\n          if (\"throw\" === t.type) throw t.arg;\n          return this.rval;\n        },\n        dispatchException: function dispatchException(e) {\n          if (this.done) throw e;\n          var r = this;\n          function handle(n, o) {\n            return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o;\n          }\n          for (var o = this.tryEntries.length - 1; o >= 0; --o) {\n            var i = this.tryEntries[o],\n              a = i.completion;\n            if (\"root\" === i.tryLoc) return handle(\"end\");\n            if (i.tryLoc <= this.prev) {\n              var c = n.call(i, \"catchLoc\"),\n                u = n.call(i, \"finallyLoc\");\n              if (c && u) {\n                if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);\n                if (this.prev < i.finallyLoc) return handle(i.finallyLoc);\n              } else if (c) {\n                if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);\n              } else {\n                if (!u) throw new Error(\"try statement without catch or finally\");\n                if (this.prev < i.finallyLoc) return handle(i.finallyLoc);\n              }\n            }\n          }\n        },\n        abrupt: function abrupt(t, e) {\n          for (var r = this.tryEntries.length - 1; r >= 0; --r) {\n            var o = this.tryEntries[r];\n            if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) {\n              var i = o;\n              break;\n            }\n          }\n          i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);\n          var a = i ? i.completion : {};\n          return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a);\n        },\n        complete: function complete(t, e) {\n          if (\"throw\" === t.type) throw t.arg;\n          return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y;\n        },\n        finish: function finish(t) {\n          for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n            var r = this.tryEntries[e];\n            if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;\n          }\n        },\n        \"catch\": function _catch(t) {\n          for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n            var r = this.tryEntries[e];\n            if (r.tryLoc === t) {\n              var n = r.completion;\n              if (\"throw\" === n.type) {\n                var o = n.arg;\n                resetTryEntry(r);\n              }\n              return o;\n            }\n          }\n          throw new Error(\"illegal catch attempt\");\n        },\n        delegateYield: function delegateYield(e, r, n) {\n          return this.delegate = {\n            iterator: values(e),\n            resultName: r,\n            nextLoc: n\n          }, \"next\" === this.method && (this.arg = t), y;\n        }\n      }, e;\n    }\n    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n      try {\n        var info = gen[key](arg);\n        var value = info.value;\n      } catch (error) {\n        reject(error);\n        return;\n      }\n      if (info.done) {\n        resolve(value);\n      } else {\n        Promise.resolve(value).then(_next, _throw);\n      }\n    }\n    function _asyncToGenerator(fn) {\n      return function () {\n        var self = this,\n          args = arguments;\n        return new Promise(function (resolve, reject) {\n          var gen = fn.apply(self, args);\n          function _next(value) {\n            asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n          }\n          function _throw(err) {\n            asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n          }\n          _next(undefined);\n        });\n      };\n    }\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n      }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) _defineProperties(Constructor, staticProps);\n      Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n      });\n      return Constructor;\n    }\n    function _defineProperty(obj, key, value) {\n      key = _toPropertyKey(key);\n      if (key in obj) {\n        Object.defineProperty(obj, key, {\n          value: value,\n          enumerable: true,\n          configurable: true,\n          writable: true\n        });\n      } else {\n        obj[key] = value;\n      }\n      return obj;\n    }\n    function _toPropertyKey(t) {\n      var i = _toPrimitive(t, \"string\");\n      return \"symbol\" == _typeof(i) ? i : String(i);\n    }\n    function _toPrimitive(t, r) {\n      if (\"object\" != _typeof(t) || !t) return t;\n      var e = t[Symbol.toPrimitive];\n      if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n      }\n      return (\"string\" === r ? String : Number)(t);\n    }\n    /**\r\n      * This class is a utility class designed to make it easier to send Fetch requests in a web application.\r\n      * It offers a simple interface for making HTTP requests\r\n      * and manage actions before and after sending the request.\r\n      */\n    var FetchRequest = /*#__PURE__*/function () {\n      function FetchRequest(_options) {\n        var _this = this;\n        _classCallCheck(this, FetchRequest);\n        _defineProperty(this, \"submitForm\", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                if (!(_this.options.callbacks && _this.options.callbacks.onPreFetch)) {\n                  _context.next = 4;\n                  break;\n                }\n                _context.next = 4;\n                return _this.preFetch();\n              case 4:\n                _context.next = 6;\n                return _this.run();\n              case 6:\n                if (!(_this.options.callbacks && _this.options.callbacks.onPostFetch)) {\n                  _context.next = 9;\n                  break;\n                }\n                _context.next = 9;\n                return _this.postFetch(_this.response, _this.status);\n              case 9:\n                _context.next = 14;\n                break;\n              case 11:\n                _context.prev = 11;\n                _context.t0 = _context[\"catch\"](0);\n                _this.handleError(_context.t0, undefined, 'Error executing query : ');\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }, _callee, null, [[0, 11]]);\n        })));\n        _defineProperty(this, \"run\", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n          var response, _this$options$callbac, _this$options, uri, _data, options, finalUri, body, method, fetchOptions, responseType;\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                response = null;\n                _context2.prev = 1;\n                _this$options = _this.options, uri = _this$options.uri, _data = _this$options.data, options = _this$options.options;\n                if (uri) {\n                  _context2.next = 5;\n                  break;\n                }\n                throw new Error(\"URI is required\");\n              case 5:\n                finalUri = uri;\n                body = null;\n                method = (options === null || options === void 0 ? void 0 : options.method) || 'GET';\n                if (method === \"GET\" && _data) {\n                  finalUri = _this.buildGetRequestUrl(uri, _data);\n                } else if (method !== \"GET\" && method !== \"HEAD\" && method !== \"OPTIONS\" && _data) {\n                  body = _this.prepareRequestBody(_data);\n                }\n                fetchOptions = {\n                  method: method,\n                  headers: options === null || options === void 0 ? void 0 : options.headers,\n                  body: body,\n                  credentials: options === null || options === void 0 ? void 0 : options.credentials,\n                  mode: options === null || options === void 0 ? void 0 : options.mode,\n                  cache: options === null || options === void 0 ? void 0 : options.cache,\n                  integrity: options === null || options === void 0 ? void 0 : options.integrity\n                };\n                if (method === \"GET\" || method === \"HEAD\" || method === \"OPTIONS\") {\n                  delete fetchOptions.body;\n                }\n                _context2.next = 13;\n                return fetch(finalUri, fetchOptions);\n              case 13:\n                response = _context2.sent;\n                _this.status = response.status;\n                if (!options) {\n                  _context2.next = 28;\n                  break;\n                }\n                responseType = options.responseType;\n                if (!responseType) {\n                  _context2.next = 28;\n                  break;\n                }\n                if (!(responseType === \"text\")) {\n                  _context2.next = 24;\n                  break;\n                }\n                _context2.next = 21;\n                return response.text();\n              case 21:\n                _context2.t0 = _context2.sent;\n                _context2.next = 27;\n                break;\n              case 24:\n                _context2.next = 26;\n                return response.json();\n              case 26:\n                _context2.t0 = _context2.sent;\n              case 27:\n                _this.response = _context2.t0;\n              case 28:\n                if ((_this$options$callbac = _this.options.callbacks) !== null && _this$options$callbac !== void 0 && _this$options$callbac.onSuccess && response.ok) {\n                  _this.options.callbacks.onSuccess(_this.response);\n                }\n                _context2.next = 34;\n                break;\n              case 31:\n                _context2.prev = 31;\n                _context2.t1 = _context2[\"catch\"](1);\n                _this.handleError(_context2.t1, response ? response.status : 0);\n              case 34:\n              case \"end\":\n                return _context2.stop();\n            }\n          }, _callee2, null, [[1, 31]]);\n        })));\n        _defineProperty(this, \"preFetch\", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n          var _data2;\n          return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n            while (1) switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(typeof _this.options.callbacks.onPreFetch === 'function')) {\n                  _context3.next = 5;\n                  break;\n                }\n                _context3.next = 3;\n                return _this.options.callbacks.onPreFetch(_this.options.data);\n              case 3:\n                _data2 = _context3.sent;\n                if (_data2) {\n                  _this.options.data = _data2.hasOwnProperty('data') ? _data2.data : _data2;\n                }\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }, _callee3);\n        })));\n        _defineProperty(this, \"postFetch\", /*#__PURE__*/function () {\n          var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(response, status) {\n            return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n              while (1) switch (_context4.prev = _context4.next) {\n                case 0:\n                  if (_this.options.submitter instanceof HTMLButtonElement) {\n                    _this.options.submitter.removeAttribute('disabled');\n                  }\n                  return _context4.abrupt(\"return\", _this.options.callbacks.onPostFetch ? _this.options.callbacks.onPostFetch(response, status) : undefined);\n                case 2:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }, _callee4);\n          }));\n          return function (_x, _x2) {\n            return _ref4.apply(this, arguments);\n          };\n        }());\n        this.options = _options;\n        this.attachSubmitterEvent();\n      }\n      _createClass(FetchRequest, [{\n        key: \"attachSubmitterEvent\",\n        value: function attachSubmitterEvent() {\n          this.options.submitter ? this.options.submitter.addEventListener('click', this.submitForm) : this.submitForm();\n        }\n      }, {\n        key: \"buildGetRequestUrl\",\n        value: function buildGetRequestUrl(uri, data) {\n          var url = new URL(uri, window.location.origin);\n          var params = new URLSearchParams();\n          if (data instanceof FormData) {\n            var _iterator = _createForOfIteratorHelper(data.entries()),\n              _step;\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var _step$value = _slicedToArray(_step.value, 2),\n                  key = _step$value[0],\n                  value = _step$value[1];\n                if (typeof value === 'string') {\n                  params.append(key, value);\n                }\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n          } else {\n            for (var _i = 0, _Object$entries = Object.entries(data); _i < _Object$entries.length; _i++) {\n              var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n                _key = _Object$entries$_i[0],\n                _value = _Object$entries$_i[1];\n              params.append(_key, _value);\n            }\n          }\n          url.search = params.toString();\n          return url.toString();\n        }\n      }, {\n        key: \"prepareRequestBody\",\n        value: function prepareRequestBody(data) {\n          var _this$options$options, _this$options$options2;\n          if (((_this$options$options = this.options.options) === null || _this$options$options === void 0 ? void 0 : _this$options$options.acceptDataFormat) === \"form-data\" && !(data instanceof FormData)) {\n            return this.convertObjectToFormData(data);\n          } else if (((_this$options$options2 = this.options.options) === null || _this$options$options2 === void 0 ? void 0 : _this$options$options2.acceptDataFormat) === \"classic-object\") {\n            return JSON.stringify(data);\n          }\n          return data;\n        }\n      }, {\n        key: \"convertObjectToFormData\",\n        value: function convertObjectToFormData(data) {\n          var formData = new FormData();\n          Object.entries(data).forEach(function (_ref5) {\n            var _ref6 = _slicedToArray(_ref5, 2),\n              key = _ref6[0],\n              value = _ref6[1];\n            return formData.append(key, value);\n          });\n          return formData;\n        }\n      }, {\n        key: \"handleError\",\n        value: function handleError(error, status) {\n          var _this$options$callbac2;\n          var message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'Fetch Request Error: ';\n          console.error(message, error);\n          if ((_this$options$callbac2 = this.options.callbacks) !== null && _this$options$callbac2 !== void 0 && _this$options$callbac2.onError) {\n            this.options.callbacks.onError(error, status || 0);\n          }\n        }\n      }]);\n      return FetchRequest;\n    }();\n\n    /******/\n    return __nested_webpack_exports__;\n    /******/\n  }();\n});\n\n//# sourceURL=webpack://easylibs/./packages/fetch-request/dist/fetch-request.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});