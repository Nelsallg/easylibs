{"version":3,"file":"fetch-request.min.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,gBAAiB,GAAIH,GACF,iBAAZC,QACdA,QAAQ,iBAAmBD,IAE3BD,EAAK,iBAAmBC,GACzB,CATD,CASGK,MAAM,I,uBCNLC,EAAsB,CAAC,E,0YCgC3B,gBAGI,WAAAC,CAAYC,GACRC,KAAKD,QAAUA,EACfC,KAAKC,sBACT,CACQ,oBAAAA,GACJD,KAAKD,QAAQG,UAAYF,KAAKD,QAAQG,UAAUC,iBAAiB,QAASH,KAAKI,YAAcJ,KAAKI,YACtG,CACc,UAAAA,G,yCACV,IACOJ,KAAKD,QAAQM,UAAUC,mBAAkBN,KAAKO,kBAC3CP,KAAKQ,MACRR,KAAKD,QAAQM,UAAUI,oBAAmBT,KAAKU,YACtD,CAAC,MAAMC,GACHX,KAAKY,YAAYD,OAAOE,EAAU,2BACtC,CACJ,G,CACc,GAAAL,G,+CACV,IAAIM,EAAyB,KAC7B,IACI,MAAM,IAAEC,EAAG,KAAEC,EAAI,QAAEjB,GAAYC,KAAKD,QACpC,IAAKgB,EAAK,MAAM,IAAIE,MAAM,mBAC1B,IAAIC,EAAWH,EACXI,EAAO,KACPpB,GAA8B,QAAnBA,EAAQqB,QAAoBJ,EACvCE,EAAWlB,KAAKqB,mBAAmBN,EAAKC,GACjCA,IACPG,EAAOnB,KAAKsB,mBAAmBN,IAEnC,MAAMO,EAA4B,CAC9BH,QAAQrB,aAAO,EAAPA,EAASqB,SAAU,MAC3BI,QAASzB,aAAO,EAAPA,EAASyB,QAClBL,KAAMA,EACNM,YAAa1B,aAAO,EAAPA,EAAS0B,YACtBC,KAAM3B,aAAO,EAAPA,EAAS2B,KACfC,MAAO5B,aAAO,EAAPA,EAAS4B,MAChBC,UAAW7B,aAAO,EAAPA,EAAS6B,WAGxBd,QAAiBe,MAAMX,EAAUK,GACjCvB,KAAKc,SAAWd,KAAKD,QAAQA,QAAQ+B,cAAsD,SAAtC9B,KAAKD,QAAQA,QAAQ+B,mBAAgChB,EAASiB,aAAejB,EAASkB,QAEjH,QAAtB,EAAAhC,KAAKD,QAAQM,iBAAS,eAAE4B,YAAanB,EAASoB,IAC9ClC,KAAKD,QAAQM,UAAU4B,UAAUjC,KAAKc,SAG9C,CAAE,MAAOH,GACLX,KAAKY,YAAYD,EAAOG,EAAWA,EAASqB,OAAS,EACzD,C,IAEU,QAAA5B,G,yCACV,GAAgD,mBAAtCP,KAAKD,QAAQM,UAAUC,WAA2B,CACxD,IAAIU,QAAahB,KAAKD,QAAQM,UAAUC,WAAWN,KAAKD,QAAQiB,MAC7DA,IACChB,KAAKD,QAAQiB,KAAOA,EAAKA,KAEjC,CACJ,G,CACc,SAAAN,G,yCAGV,OAFGV,KAAKD,QAAQG,qBAAqBkC,mBACpCpC,KAAKD,QAAQG,UAAUmC,gBAAgB,YACjCrC,KAAKD,QAAQM,UAAUI,YAAcT,KAAKD,QAAQM,UAAUI,mBAAgBI,CACvF,G,CACQ,kBAAAQ,CAAmBN,EAAaC,GACpC,MAAMsB,EAAM,IAAIC,IAAIxB,EAAKyB,OAAOC,SAASC,QACnCC,EAAS,IAAIC,gBACnB,GAAI5B,aAAgB6B,SAChB,IAAK,IAAKC,EAAKC,KAAU/B,EAAKgC,UACL,iBAAVD,GACPJ,EAAOM,OAAOH,EAAKC,QAK3B,IAAK,IAAKD,EAAKC,KAAUG,OAAOF,QAAQhC,GACpC2B,EAAOM,OAAOH,EAAKC,GAI3B,OADAT,EAAIa,OAASR,EAAOS,WACbd,EAAIc,UACf,CACQ,kBAAA9B,CAAmBN,G,QACvB,MAA+C,eAAvB,QAApB,EAAAhB,KAAKD,QAAQA,eAAO,eAAEsD,mBAAsCrC,aAAgB6B,SAE1B,oBAAvB,QAApB,EAAA7C,KAAKD,QAAQA,eAAO,eAAEsD,kBACtBC,KAAKC,UAAUvC,GAEnBA,EAJIhB,KAAKwD,wBAAwBxC,EAK5C,CACQ,uBAAAwC,CAAwBxC,GAC5B,MAAMyC,EAAW,IAAIZ,SAErB,OADAK,OAAOF,QAAQhC,GAAM0C,SAAQ,EAAEZ,EAAKC,KAAWU,EAASR,OAAOH,EAAKC,KAC7DU,CACX,CACQ,WAAA7C,CAAYD,EAAYwB,EAAiBwB,EAAe,yB,MAC5DC,QAAQjD,MAAMgD,EAAShD,IACG,QAAtB,EAAAX,KAAKD,QAAQM,iBAAS,eAAEwD,UACxB7D,KAAKD,QAAQM,UAAUwD,QAAQlD,EAAOwB,GAAU,EAExD,E,GDpIgB,KAAK,EAAGtC,G","sources":["webpack://@easylibs/fetch-request/webpack/universalModuleDefinition","webpack://@easylibs/fetch-request/webpack/startup","webpack://@easylibs/fetch-request/./src/fetch-request.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"fetch-request\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fetch-request\"] = factory();\n\telse\n\t\troot[\"fetch-request\"] = factory();\n})(self, () => {\nreturn ","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[505](0, __webpack_exports__);\n","declare type HttpMethod = 'GET' | 'POST';\r\ndeclare type Headers = Record<string, string>;\r\n\r\ndeclare interface FetchRequestOptions {\r\n    method: HttpMethod,\r\n    headers?: Headers,\r\n    credentials?: \"omit\" | \"same-origin\" | \"include\",\r\n    mode?: \"cors\" | \"no-cors\" | \"same-origin\",\r\n    cache?: \"default\" | \"force-cache\" | \"no-cache\" | \"no-store\" | \"only-if-cached\" | \"reload\",\r\n    integrity?: string,\r\n    timeOut?: number,\r\n    contentType?: string,\r\n    acceptDataFormat?: \"form-data\" | \"classic-object\" | \"array\",\r\n    responseType: 'json' | 'text',\r\n}\r\n\r\ndeclare interface FetchRequestCallbacks {\r\n    onPostFetch?: (response?: any) => void,\r\n    onPreFetch?: (that?: any) => Promise<any>,\r\n    onSuccess?: (response: any) => void,\r\n    onError?: (error: Error, status: number) => void\r\n}\r\n\r\ndeclare type FetchRequestType = {\r\n    uri: string,\r\n    data?: Record<string, string> | FormData | null,\r\n    submitter?: HTMLElement | null,\r\n    options?: FetchRequestOptions,\r\n    callbacks?: FetchRequestCallbacks\r\n}\r\n/**\r\n  * This class is a utility class designed to make it easier to send Fetch requests in a web application.\r\n  * It offers a simple interface for making HTTP requests\r\n  * and manage actions before and after sending the request.\r\n  */\r\nexport default class FetchRequest{\r\n    private options: FetchRequestType;\r\n    private response: any;\r\n    constructor(options: FetchRequestType) {\r\n        this.options = options;\r\n        this.attachSubmitterEvent();\r\n    }\r\n    private attachSubmitterEvent() {\r\n        this.options.submitter ? this.options.submitter.addEventListener('click', this.submitForm) : this.submitForm();  \r\n    }\r\n    private async submitForm(){\r\n        try{\r\n            if(this.options.callbacks.onPreFetch){await this.preFetch();}\r\n            await this.run();\r\n            if(this.options.callbacks.onPostFetch){await this.postFetch();}\r\n        }catch(error){\r\n            this.handleError(error, undefined,'Error executing query : ');\r\n        }\r\n    }\r\n    private async run(){\r\n        let response:Response|null = null;\r\n        try {\r\n            const { uri, data, options } = this.options;\r\n            if (!uri) throw new Error(\"URI is required\");\r\n            let finalUri = uri;\r\n            let body = null;\r\n            if (options && options.method === \"GET\" && data) {\r\n                finalUri = this.buildGetRequestUrl(uri, data);\r\n            } else if (data) {\r\n                body = this.prepareRequestBody(data);\r\n            }\r\n            const fetchOptions: RequestInit = {\r\n                method: options?.method || 'GET',\r\n                headers: options?.headers,\r\n                body: body,\r\n                credentials: options?.credentials,\r\n                mode: options?.mode,\r\n                cache: options?.cache,\r\n                integrity: options?.integrity,\r\n            };\r\n\r\n            response = await fetch(finalUri, fetchOptions);\r\n            this.response = this.options.options.responseType && this.options.options.responseType === \"text\" ? await response.text() : await response.json();\r\n\r\n            if (this.options.callbacks?.onSuccess && response.ok) {\r\n                this.options.callbacks.onSuccess(this.response);\r\n            }\r\n            \r\n        } catch (error) {\r\n            this.handleError(error, response ? response.status : 0);\r\n        }\r\n    }\r\n    private async preFetch (){\r\n        if(typeof this.options.callbacks.onPreFetch === 'function') {\r\n            let data = await this.options.callbacks.onPreFetch(this.options.data);\r\n            if(data){\r\n                this.options.data = data.data;\r\n            }\r\n        }\r\n    }\r\n    private async postFetch (){\r\n        if(this.options.submitter instanceof HTMLButtonElement)\r\n        {this.options.submitter.removeAttribute('disabled');}\r\n        return this.options.callbacks.onPostFetch ? this.options.callbacks.onPostFetch() : undefined;\r\n    }\r\n    private buildGetRequestUrl(uri: string, data: Record<string, string> | FormData): string {\r\n        const url = new URL(uri, window.location.origin);\r\n        const params = new URLSearchParams();\r\n        if (data instanceof FormData) {\r\n            for (let [key, value] of data.entries()) {\r\n                if (typeof value === 'string') {\r\n                    params.append(key, value);\r\n                }\r\n                // If needed, handle File type values differently\r\n            }\r\n        } else {\r\n            for (let [key, value] of Object.entries(data)) {\r\n                params.append(key, value);\r\n            }\r\n        }\r\n        url.search = params.toString();\r\n        return url.toString();\r\n    }\r\n    private prepareRequestBody(data: Record<string, string> | FormData): FormData | Record<string, string> | string {\r\n        if (this.options.options?.acceptDataFormat === \"form-data\" && !(data instanceof FormData)) {\r\n            return this.convertObjectToFormData(data);\r\n        } else if (this.options.options?.acceptDataFormat === \"classic-object\") {\r\n            return JSON.stringify(data);\r\n        }\r\n        return data;\r\n    }\r\n    private convertObjectToFormData(data: Record<string, string>): FormData {\r\n        const formData = new FormData();\r\n        Object.entries(data).forEach(([key, value]) => formData.append(key, value));\r\n        return formData;\r\n    }\r\n    private handleError(error: any, status?: number, message:string='Fetch Request Error: ') {\r\n        console.error(message, error);\r\n        if (this.options.callbacks?.onError) {\r\n            this.options.callbacks.onError(error, status || 0);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_exports__","constructor","options","this","attachSubmitterEvent","submitter","addEventListener","submitForm","callbacks","onPreFetch","preFetch","run","onPostFetch","postFetch","error","handleError","undefined","response","uri","data","Error","finalUri","body","method","buildGetRequestUrl","prepareRequestBody","fetchOptions","headers","credentials","mode","cache","integrity","fetch","responseType","text","json","onSuccess","ok","status","HTMLButtonElement","removeAttribute","url","URL","window","location","origin","params","URLSearchParams","FormData","key","value","entries","append","Object","search","toString","acceptDataFormat","JSON","stringify","convertObjectToFormData","formData","forEach","message","console","onError"],"sourceRoot":""}