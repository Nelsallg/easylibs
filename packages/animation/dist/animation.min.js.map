{"version":3,"file":"animation.min.js","mappings":"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","sources":["webpack://@easylibs/animation/webpack/universalModuleDefinition","webpack://@easylibs/animation/../../node_modules/path-browserify/index.js","webpack://@easylibs/animation/./src/scripts/helpers.ts","webpack://@easylibs/animation/./src/scripts/loader.ts","webpack://@easylibs/animation/webpack/bootstrap","webpack://@easylibs/animation/./src/animation.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"animation\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"animation\"] = factory();\n\telse\n\t\troot[\"animation\"] = factory();\n})(self, () => {\nreturn ","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","import { loadCSSAnimation } from \"./loader\";\r\nimport { AnimeOptions, LoaderOptions } from \"./types\";\r\n\r\n/**\r\n   * Effectue une animation de commutation sur un élément HTML spécifié.\r\n   * @param element - L'élément HTML sur lequel l'animation doit être appliquée.\r\n   * @param fromInToOut - Détermine si l'animation va de l'état \"in\" (entrée) à l'état \"out\" (sortie) ou vice versa.\r\n   * @param animation - Les informations sur le type et la position de l'animation (facultatif).\r\n   */\r\nfunction switchAnimation(\r\n    element: HTMLElement,\r\n    fromInToOut: boolean,\r\n    animCSSProps?:LoaderOptions|null,\r\n    clearAfterApplying?: boolean\r\n  ): void {\r\n    if (animCSSProps) {\r\n      const animeType = animCSSProps.animationType ?? \"fade\";\r\n      const animePosition = animCSSProps.animationPosition ?? \"top\";\r\n      loadCSSAnimation(animCSSProps); // Charge les animations CSS si ce n'est pas déjà fait.\r\n      if (fromInToOut) {\r\n        element.classList.remove(`${animeType}-out-${animePosition}`);\r\n        element.classList.add(`${animeType}-in-${animePosition}`);\r\n\r\n        if (clearAfterApplying && clearAfterApplying === true) {\r\n          setTimeout(() => {\r\n            element.classList.remove(`${animeType}-in-${animePosition}`);\r\n          }, 1000);\r\n        }\r\n      } else {\r\n        element.classList.remove(`${animeType}-in-${animePosition}`);\r\n        element.classList.add(`${animeType}-out-${animePosition}`);\r\n\r\n        if (clearAfterApplying && clearAfterApplying === true) {\r\n          setTimeout(() => {\r\n            element.classList.remove(`${animeType}-out-${animePosition}`);\r\n          }, 1000);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\nexport function getElement(options: AnimeOptions): { element: HTMLElement; animateElement?: HTMLElement } {\r\n    const _element = options.element;\r\n    return {\r\n      element: _element instanceof HTMLElement ? _element : _element?.element,\r\n      animateElement: _element instanceof HTMLElement ? undefined : _element?.animateElement,\r\n    };\r\n  }\r\n  \r\nexport function applyAnimation(\r\n  element: HTMLElement, \r\n  animateElement: HTMLElement | undefined, \r\n  fromInToOut: boolean, \r\n  options: AnimeOptions,\r\n  animCSSProps?:LoaderOptions): void {\r\n    switchAnimation(animateElement ?? element, fromInToOut, animCSSProps);\r\n    if (options.display !== null) {\r\n      setTimeout(() => {\r\n        element.style.display = options.display ?? \"none\";\r\n      }, options.delay || 0);\r\n    } else {\r\n      setTimeout(() => {\r\n        element.remove();\r\n      }, options.delay || 0);\r\n    }\r\n  }\r\n  ","import path from \"path\";\r\nimport { LoaderOptions } from \"./types\";\r\n\r\n/**\r\n * Fonction principale pour charger, transformer et appliquer le mixin avec des paramètres optionnels.\r\n */\r\nexport function loadCSSAnimation(options:LoaderOptions) {\r\n    fetchSCSS(options.animationType)\r\n      .then((SCSSContent:string) => {\r\n        const mixinName = `${options.animationType}-${options.animationEnter}-${options.animationPosition}`;\r\n        const css = convertMixinToCSS(SCSSContent, mixinName, options.animCSSProps);\r\n        console.log({css})\r\n        if (css) {\r\n          addCSSToDocument(css); // Ajoute le CSS transformé à la balise <style>\r\n        } else {\r\n          console.error('Mixin non trouvé.');\r\n        }\r\n      })\r\n      .catch(error => console.error(error));\r\n}\r\n\r\n/**\r\n * Fonction pour charger le contenu d'un fichier SCSS\r\n */\r\nfunction fetchSCSS(animationType:string) {\r\n    return new Promise((resolve, reject) => {\r\n      // Utiliser AJAX, fetch ou une autre méthode pour charger le fichier SCSS\r\n      const url = path.resolve(__dirname, `node_modules/@easylibs/animation/dist/assets/styles/${animationType}.scss`);\r\n      fetch(url)\r\n        .then(response => {\r\n          if (!response.ok) {\r\n            throw new Error('Erreur lors du chargement du fichier SCSS');\r\n          }\r\n          return response.text();\r\n        })\r\n        .then(data => resolve(data))\r\n        .catch(error => reject(error));\r\n    });\r\n}\r\n\r\n/**\r\n * Fonction pour trouver et convertir un mixin en CSS, avec gestion des paramètres optionnels.\r\n */\r\nfunction convertMixinToCSS(SCSSContent:string, mixinName:string, animCSSProps:Record<string,any>) \r\n{\r\n  // Trouver le début du mixin spécifié\r\n  const mixinStartRegex = new RegExp(`(@mixin ${mixinName}\\\\(.*?\\\\)\\\\s*{)`, 's');\r\n  let mixinStartMatch = mixinStartRegex.exec(SCSSContent);\r\n  if (!mixinStartMatch) return null;\r\n  // Extraire le contenu à partir du début du mixin\r\n  const startIndex = mixinStartMatch.index + mixinStartMatch[1].length;\r\n  const SCSSContentAfterMixin = SCSSContent.substring(startIndex);\r\n  // Chercher le prochain '@' qui n'est pas immédiatement suivi par 'keyframes' après le mixin spécifié\r\n  const mixinEndRegex = /@keyframes[\\s\\S]+?}([\\s\\S]*?)(?=@mixin|$)/;\r\n  let mixinEndMatch = mixinEndRegex.exec(SCSSContentAfterMixin);\r\n\r\n  if (!mixinEndMatch) return null;\r\n\r\n  // Extraire tout le contenu jusqu'au prochain '@mixin' après les @keyframes\r\n  const endIndex = mixinEndMatch.index + mixinEndMatch[0].length;\r\n  let mixinContent = SCSSContent.substring(mixinStartMatch.index, startIndex + endIndex);\r\n  // Remplacer les variables animCSSProps dans le contenu extrait, si fourni\r\n  if (animCSSProps) {\r\n      Object.keys(animCSSProps).forEach(key => {\r\n          const paramRegex = new RegExp(`\\\\$${key}`, 'g');\r\n          mixinContent = mixinContent.replace(paramRegex, animCSSProps[key]);\r\n      });\r\n  }\r\n  return parseSCSSToCSS(mixinContent,animCSSProps);\r\n}\r\nfunction parseSCSSToCSS(mixinContent: string, animCSSProps: Record<string, any>): string {\r\n  // Pré-nettoyage pour supprimer les déclarations @mixin et les blocs @keyframes\r\n  let cleanedContent = mixinContent.replace(/@mixin\\s+[^\\{]+\\{/, '')\r\n  .replace(/@keyframes\\s+[^\\{]+\\{([^\\}]+\\})+\\}/g, '');\r\n  // Extraire les valeurs par défaut des paramètres du mixin\r\n  const defaultValuesRegex = /\\$([a-zA-Z0-9_-]+):\\s*([^;]+);/g;\r\n  let defaultValueMatches;\r\n  let defaultValues: Record<string, string> = {};\r\n  while ((defaultValueMatches = defaultValuesRegex.exec(cleanedContent)) !== null) {\r\n    defaultValues[defaultValueMatches[1]] = defaultValueMatches[2].trim();\r\n    // Supprimer la déclaration de la variable avec sa valeur par défaut\r\n    cleanedContent = cleanedContent.replace(defaultValueMatches[0], '');\r\n  }\r\n  // Remplacer les variables dans le contenu du mixin, en gérant spécifiquement $element\r\n  const variableRegex = /\\$([a-zA-Z0-9_-]+)/g;\r\n  cleanedContent = cleanedContent.replace(variableRegex, (match, varName) => {\r\n    // Traitement spécial pour $element\r\n    if (varName === 'element' && (!animCSSProps || !animCSSProps.hasOwnProperty(varName))) {\r\n      return ''; // Remplacer par une chaîne vide si $element est non défini\r\n    } else if (animCSSProps && animCSSProps.hasOwnProperty(varName)) {\r\n      return animCSSProps[varName]; // Utiliser la valeur d'animCSSProps si disponible\r\n    } else if (defaultValues.hasOwnProperty(varName)) {\r\n      return defaultValues[varName]; // Sinon, utiliser la valeur par défaut\r\n    } else {\r\n      return match; // Conserver la variable non remplacée si non trouvée\r\n    }\r\n  });\r\n  // Nettoyage final pour supprimer toute syntaxe résiduelle spécifique à SCSS\r\n  cleanedContent = cleanedContent\r\n  .trim()\r\n  .replace(/^\\{|\\}$/g, '') // Supprimer les accolades extérieures\r\n  .replace(/\\#{\\$(.*?)}/g, '') // Supprimer les interpolations SCSS restantes\r\n  .replace(/(\\r\\n|\\r|\\n){2,}/g, '\\n') // Réduire les sauts de ligne multiples\r\n  .replace(/\\s{2,}/g, ' '); // Réduire les espaces multiples\r\n\r\n  return cleanedContent;\r\n}\r\n\r\n\r\n/**\r\n * Ajoute ou met à jour une balise <style> avec le CSS généré\r\n */\r\nfunction addCSSToDocument(css:string) {\r\n    let styleTag = document.getElementById('@animation-style');\r\n    if (!styleTag) {\r\n      styleTag = document.createElement('style');\r\n      styleTag.id = '@animation-style';\r\n      document.head.appendChild(styleTag);\r\n    }\r\n    styleTag.innerHTML += css; // Ajoute le nouveau CSS à la balise <style>\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { applyAnimation, getElement } from \"./scripts/helpers\";\r\nimport { AnimeOptions, LoaderOptions } from \"./scripts/types\";\r\n\r\n/**\r\n * Provides animation functionalities for HTML elements.\r\n */\r\nexport default class Animation {\r\n  /**\r\n   * Stops the propagation of the given event.\r\n   * @param e The event to stop propagation for.\r\n   */\r\n  private static stopPropagation(e: Event): void {\r\n    e.stopPropagation();\r\n  }\r\n\r\n  /**\r\n   * Performs an entrance animation on the specified HTML element.\r\n   * @param options Configuration options for the animation.\r\n   */\r\n  public animeIn(options: AnimeOptions, animCSSProps?:LoaderOptions|null): void {\r\n    const { element, animateElement } = getElement(options);\r\n    const fromInToOut = true;\r\n    applyAnimation(element, animateElement, fromInToOut, options,animCSSProps);\r\n  }\r\n\r\n  /**\r\n   * Performs an exit animation on the specified HTML element, then hides or removes it.\r\n   * @param options Configuration options for the animation.\r\n   */\r\n  public animeOut(options: AnimeOptions,animCSSProps?:LoaderOptions|null): void {\r\n    const { element, animateElement } = getElement(options);\r\n    const fromInToOut = false;\r\n    applyAnimation(element, animateElement, fromInToOut, options, animCSSProps);\r\n  }\r\n\r\n  /**\r\n   * Performs either an entrance or exit animation on the specified HTML element in response to open and close button events.\r\n   * @param options Configuration options for the animation, including elements and buttons involved.\r\n   */\r\n  public animeInOut(options: AnimeOptions): void {\r\n    let modalIsOpen = false;\r\n    const toggleModal = () => {\r\n      if (!modalIsOpen) {\r\n        this.animeIn(options);\r\n      } else {\r\n        this.animeOut(options);\r\n      }\r\n      modalIsOpen = !modalIsOpen;\r\n    };\r\n\r\n    options.openButton?.addEventListener(\"click\", toggleModal);\r\n    options.closeButton?.addEventListener(\"click\", toggleModal);\r\n  }\r\n}\r\n"],"names":["root","factory","exports","module","define","amd","self","assertPath","path","TypeError","JSON","stringify","normalizeStringPosix","allowAboveRoot","code","res","lastSegmentLength","lastSlash","dots","i","length","charCodeAt","lastSlashIndex","lastIndexOf","slice","posix","resolve","cwd","resolvedPath","resolvedAbsolute","arguments","undefined","process","normalize","isAbsolute","trailingSeparator","join","joined","arg","relative","from","to","fromStart","fromEnd","fromLen","toStart","toLen","lastCommonSep","fromCode","out","_makeLong","dirname","hasRoot","end","matchedSlash","basename","ext","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","pathObject","sep","dir","base","name","_format","parse","ret","delimiter","win32","options","_element","element","HTMLElement","animateElement","fromInToOut","animCSSProps","clearAfterApplying","animeType","animationType","animePosition","animationPosition","loadCSSAnimation","classList","remove","add","setTimeout","switchAnimation","display","style","delay","Promise","reject","url","__dirname","fetch","then","response","ok","Error","text","data","catch","error","SCSSContent","css","mixinName","mixinStartRegex","RegExp","mixinStartMatch","exec","startIndex","index","SCSSContentAfterMixin","substring","mixinEndMatch","endIndex","mixinContent","Object","keys","forEach","key","paramRegex","replace","cleanedContent","defaultValuesRegex","defaultValueMatches","defaultValues","trim","variableRegex","match","varName","hasOwnProperty","parseSCSSToCSS","convertMixinToCSS","animationEnter","console","log","styleTag","document","getElementById","createElement","id","head","appendChild","innerHTML","addCSSToDocument","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call","stopPropagation","e","animeIn","getElement","applyAnimation","animeOut","animeInOut","modalIsOpen","toggleModal","this","openButton","addEventListener","closeButton"],"sourceRoot":""}