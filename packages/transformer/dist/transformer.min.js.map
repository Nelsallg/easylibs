{"version":3,"file":"transformer.min.js","mappings":"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","sources":["webpack://@easylibs/transformer/webpack/universalModuleDefinition","webpack://@easylibs/transformer/webpack/startup","webpack://@easylibs/transformer/./src/transformer.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"transformer\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"transformer\"] = factory();\n\telse\n\t\troot[\"transformer\"] = factory();\n})(self, () => {\nreturn ","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[59](0, __webpack_exports__);\n","function getMimeType(base64String: string, get: string = \"both\"): string {\r\n  const extension = base64String\r\n    .split(\",\")[0]\r\n    .split(\":\")[1]\r\n    .split(\";\")[0]\r\n    .split(\"/\")[1];\r\n  const fileType = base64String\r\n    .split(\",\")[0]\r\n    .split(\":\")[1]\r\n    .split(\";\")[0]\r\n    .split(\"/\")[0];\r\n\r\n  if (\"type\" === get) {\r\n    return fileType;\r\n  }\r\n  if (\"extension\" === get) {\r\n    return extension;\r\n  }\r\n  return fileType + \"/\" + extension;\r\n}\r\n\r\n\r\nexport namespace Transformer {\r\n  export class Base64Transformer {\r\n    protected base64String: string = \"\";\r\n    /**\r\n     * Convertit une chaîne base64 en objet File.\r\n     * @param base64String - La chaîne encodée en base64.\r\n     * @param fileName - (Optionnel) Le nom du fichier.\r\n     * @returns Le fichier résultant.\r\n     */\r\n    public toFile(base64String: string, fileName?: string): File {\r\n      this.base64String = base64String;\r\n      const byteCharacters = window.atob(base64String.split(\",\")[1]);\r\n      const byteArrays: Array<Uint8Array> = [];\r\n      let _fileName = \"\";\r\n      for (let offset = 0; offset < byteCharacters.length; offset += 512) {\r\n        const slice = byteCharacters.slice(offset, offset + 512);\r\n        const byteNumbers = new Array(slice.length);\r\n        for (let i = 0; i < slice.length; i++) {\r\n          byteNumbers[i] = slice.charCodeAt(i);\r\n        }\r\n        const byteArray = new Uint8Array(byteNumbers);\r\n        byteArrays.push(byteArray);\r\n      }\r\n      const extension = getMimeType(base64String, \"extension\");\r\n      const fileType = getMimeType(base64String, \"type\");\r\n      if (fileName) {\r\n        _fileName = fileName;\r\n      } else {\r\n        _fileName = `tranformed_file.${extension}`;\r\n      }\r\n      return new File(byteArrays, _fileName, {\r\n        type: `${fileType}/${extension}`,\r\n      });\r\n    }\r\n    /**\r\n     * Convertit un objet File en chaîne base64.\r\n     * @param file - Le fichier à convertir en base64.\r\n     * @returns La chaîne base64 résultante (sous forme de promesse).\r\n     */\r\n    public fromFile(file: File): Promise<any> {\r\n      return new Promise((resolve, reject) => {\r\n        const reader = new FileReader();\r\n        reader.onloadend = () => {\r\n          resolve(reader.result);\r\n        };\r\n        reader.onerror = (error) => {\r\n          reject(error);\r\n        };\r\n        reader.readAsDataURL(file);\r\n      });\r\n    }\r\n    /**\r\n     * Convertit une chaîne base64 en tableau Uint8Array.\r\n     * @param base64String - La chaîne encodée en base64.\r\n     * @returns Le tableau Uint8Array résultant.\r\n     */\r\n    public toUint8Array(base64String: string): Uint8Array {\r\n      const binaryString = window.atob(base64String.split(\",\")[1]);\r\n      const { length } = binaryString;\r\n      const bytes = new Uint8Array(length);\r\n      for (let i = 0; i < length; i++) {\r\n        bytes[i] = binaryString.charCodeAt(i);\r\n      }\r\n      return bytes;\r\n    }\r\n    /**\r\n     * Convertit un tableau Uint8Array en chaîne base64.\r\n     * @param uint8Array - Le tableau Uint8Array à convertir en base64.\r\n     * @returns La chaîne base64 résultante.\r\n     */\r\n    public fromUint8Array(uint8Array: Uint8Array): string {\r\n      let binaryString = \"\";\r\n      for (let i = 0; i < uint8Array.length; i++) {\r\n        binaryString += String.fromCharCode(uint8Array[i]);\r\n      }\r\n      return window.btoa(binaryString);\r\n    }\r\n    /**\r\n     * Convertit un objet Blob en chaîne base64 ou ArrayBuffer.\r\n     * @param blob - Le Blob à convertir.\r\n     * @returns La chaîne base64 ou ArrayBuffer résultante (sous forme de promesse).\r\n     */\r\n    public async fromBlob(blob: Blob): Promise<string | ArrayBuffer> {\r\n      return new Promise<string | ArrayBuffer>((resolve) => {\r\n        const reader = new FileReader();\r\n        reader.onloadend = function () {\r\n          const { result } = reader;\r\n          const base64String = result || \"\";\r\n          resolve(base64String);\r\n        };\r\n        reader.readAsDataURL(blob);\r\n      });\r\n    }\r\n  }\r\n  export class BlobTransformer {\r\n    /**\r\n     * Convertit un tableau Uint8Array en objet Blob.\r\n     * @param uint8Array - Le tableau Uint8Array à convertir en Blob.\r\n     * @param contentType - (Optionnel) Le type de contenu du Blob.\r\n     * @returns Le Blob résultant.\r\n     */\r\n    public fromUint8Array(uint8Array: Uint8Array, contentType?: string): Blob {\r\n      contentType = contentType ?? \"\";\r\n      return new Blob([uint8Array], { type: contentType });\r\n    }\r\n    /**\r\n     * Crée un Blob à partir d'un objet File.\r\n     * @param file - Le fichier à convertir en Blob.\r\n     * @returns Le Blob résultant.\r\n     */\r\n    public fromFile(file: File): Blob {\r\n      return file.slice(0, file.size, file.type);\r\n    }\r\n    /**\r\n     * Crée un Blob à partir d'une chaîne encodée en base64.\r\n     * @param base64String - La chaîne encodée en base64.\r\n     * @param contentType - (Optionnel) Le type de contenu du Blob.\r\n     * @returns Le Blob résultant.\r\n     */\r\n    public fromBase64String(base64String: string, contentType?: string): Blob {\r\n      contentType = contentType || \"\";\r\n      const byteCharacters = window.atob(base64String.split(\",\")[1]);\r\n      const byteNumbers = new Array(byteCharacters.length);\r\n      for (let i = 0; i < byteCharacters.length; i++) {\r\n        byteNumbers[i] = byteCharacters.charCodeAt(i);\r\n      }\r\n      const byteArray = new Uint8Array(byteNumbers);\r\n      return new Blob([byteArray], { type: contentType });\r\n    }\r\n  }\r\n\r\n  export class FileTransformer {\r\n    /**\r\n     * Convertit un fichier en chaîne base64.\r\n     * @param file - Le fichier à convertir en base64.\r\n     * @returns La chaîne base64 résultante (sous forme de promesse).\r\n     */\r\n    public toBase64(file: File): Promise<unknown> {\r\n      return new Promise((resolve, reject) => {\r\n        const reader = new FileReader();\r\n        reader.onloadend = () => {\r\n          resolve(reader.result);\r\n        };\r\n        reader.onerror = (error) => {\r\n          reject(error);\r\n        };\r\n        reader.readAsDataURL(file);\r\n      });\r\n    }\r\n    /**\r\n     * Convertit une chaîne base64 en objet File.\r\n     * @param base64String - La chaîne encodée en base64.\r\n     * @param contentType - (Optionnel) Le type de contenu du fichier.\r\n     * @param fileName - (Optionnel) Le nom du fichier.\r\n     * @param formatString - (Optionnel) Indique si la chaîne base64 est formatée.\r\n     * @returns Le fichier résultant.\r\n     */\r\n    public fromBase64String(\r\n      base64String: string,\r\n      contentType?: string | null,\r\n      fileName?: string | null,\r\n      formatString: boolean = true\r\n    ): File {\r\n      contentType = contentType || \"\";\r\n      const fileInfo = formatString ? base64String.split(\",\")[1] : base64String;\r\n      const byteCharacters = window.atob(fileInfo);\r\n      const byteNumbers = new Array(byteCharacters.length);\r\n      for (let i = 0; i < byteCharacters.length; i++) {\r\n        byteNumbers[i] = byteCharacters.charCodeAt(i);\r\n      }\r\n      const byteArray = new Uint8Array(byteNumbers);\r\n      const blob = new Blob([byteArray], { type: contentType });\r\n      fileName = fileName || \"image\";\r\n      return new File([blob], fileName, { type: contentType });\r\n    }\r\n    /**\r\n     * Convertit un tableau Uint8Array en objet File.\r\n     * @param uint8Array - Le tableau Uint8Array.\r\n     * @param mimeType - Le type MIME du fichier.\r\n     * @param fileName - Le nom du fichier.\r\n     * @returns Le fichier résultant.\r\n     */\r\n    public fromUint8Array(\r\n      uint8Array: Uint8Array,\r\n      mimeType: string,\r\n      fileName: string\r\n    ): File {\r\n      return new File(uint8Array as any, fileName, { type: mimeType });\r\n    }\r\n  }\r\n  export class FormDataTransformer {\r\n    private _data: object | undefined;\r\n    constructor(data: object | FormData) {\r\n      this._data = data;\r\n    }\r\n    /**\r\n     * Transforme les données en un objet FormData.\r\n     * @returns L'objet FormData résultant.\r\n     */\r\n    public transform(): FormData {\r\n      const formData = new FormData();\r\n      if (typeof this._data === \"object\") {\r\n        let data = this._data as any;\r\n        try {\r\n          for (const key in this._data) {\r\n            if (this._data.hasOwnProperty(key)) {\r\n              formData.append(key, data[key]);\r\n            }\r\n          }\r\n        } catch (error) {\r\n          console.error(\"Erreur détectée: \" + error);\r\n        }\r\n      }\r\n      return formData;\r\n    }\r\n    /**\r\n     * Revertit un objet FormData en objet JavaScript.\r\n     * @returns L'objet JavaScript résultant.\r\n     */\r\n    public reverse(): object {\r\n      let elementObject: object = {};\r\n      if (this._data instanceof FormData) {\r\n        try {\r\n          const tempObject: any = {};\r\n          this._data.forEach((value, key) => {\r\n            tempObject[key] = value;\r\n          });\r\n          elementObject = { ...tempObject };\r\n        } catch (error) {\r\n          console.error(\"Erreur détectée: \" + error);\r\n        }\r\n      }\r\n      return elementObject;\r\n    }\r\n    /**\r\n     * Option de transformation spécifique.\r\n     * @param option - L'option de transformation ('onlyobject', 'onlyformdata', 'auto').\r\n     * @returns L'objet ou le FormData résultant en fonction de l'option spécifiée.\r\n     */\r\n    public option(option: string) {\r\n      if (option === \"onlyobject\") {\r\n        if (this._data instanceof FormData) {\r\n          return this.reverse();\r\n        }\r\n        return this._data;\r\n      }\r\n      if (option === \"onlyformdata\") {\r\n        if (this._data instanceof FormData) {\r\n          return this._data;\r\n        }\r\n        return this.transform();\r\n      }\r\n      if (option === \"auto\") {\r\n        return this.auto();\r\n      }\r\n    }\r\n    private auto() {\r\n      if (this._data instanceof FormData) {\r\n        return this.reverse();\r\n      } else {\r\n        return this.transform();\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_exports__","Transformer","getMimeType","base64String","get","extension","split","fileType","Base64Transformer","toFile","fileName","this","byteCharacters","window","atob","byteArrays","_fileName","offset","length","slice","byteNumbers","Array","i","charCodeAt","byteArray","Uint8Array","push","File","type","fromFile","file","Promise","resolve","reject","reader","FileReader","onloadend","result","onerror","error","readAsDataURL","toUint8Array","binaryString","bytes","fromUint8Array","uint8Array","String","fromCharCode","btoa","fromBlob","blob","BlobTransformer","contentType","Blob","size","fromBase64String","FileTransformer","toBase64","formatString","fileInfo","mimeType","FormDataTransformer","constructor","data","_data","transform","formData","FormData","key","hasOwnProperty","append","console","reverse","elementObject","tempObject","forEach","value","option","auto"],"sourceRoot":""}